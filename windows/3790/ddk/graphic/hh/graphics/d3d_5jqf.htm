<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Optimized Textures</TITLE>
<SCRIPT SRC="../scripts/linkcss.js"></SCRIPT><SCRIPT SRC="../scripts/langref.js"></SCRIPT><META NAME="MS-HKWD" CONTENT="Optimized Textures">
</HEAD>
<BODY TOPMARGIN="0">

<TABLE CLASS="buttonbarshade" CELLSPACING=0><TR><TD>&nbsp;</TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING=0>
<TR ID="hdr"><TD CLASS="runninghead" NOWRAP>Display&nbsp;and&nbsp;Print&nbsp;Devices:&nbsp;Windows&nbsp;DDK</TD></TR>
</TABLE>
<H2><A NAME="ddk_optimized_textures_gg"></A>Optimized Textures</H2>

<P>In order to increase performance, some hardware vendors have changed their texture formats from the standard Microsoft DirectDraw® surface format. One approach is to tile the pixels so they are arranged in memory with 2D locality of reference. For example, instead of arranging the pixels scan line by scan line like this:</P>

<TABLE>

<TR VALIGN="top">
<TD width=17%>0</TD>
<TD width=20%>1</TD>
<TD width=21%>2</TD>
<TD width=21%>3</TD>
<TD width=21%>… <I>width</I></TD>
</TR>

<TR VALIGN="top">
<TD width=17%><I>width</I>+1</TD>
<TD width=20%><I>width</I>+2</TD>
<TD width=21%><I>width</I>+3</TD>
<TD width=21%><I>width</I>+4</TD>
<TD width=21%>…</TD>
</TR>
</TABLE><BR>

<P>pixels are arranged in 4x8 blocks of DWORDs:</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%>0</TD>
<TD width=26%>1</TD>
<TD width=26%>2</TD>
<TD width=27%>3</TD>
</TR>

<TR VALIGN="top">
<TD width=21%>4</TD>
<TD width=26%>5</TD>
<TD width=26%>6</TD>
<TD width=27%>7</TD>
</TR>
</TABLE><BR>

<P>Thus, a single contiguous 32-byte memory reference pulls in a 4x8 block of pixels for use by the rasterizer. This layout maps much better to the pattern of memory references typically generated by the rasterizer than does the standard DirectDraw layout. Such schemes are referred to as ‘swizzling’ or ‘patching’ the texture. These operations are relatively more rapid to perform, and do not affect the size of the memory surface allocated. However, there is still significant latency introduced by this operation that applications must control.</P>

<P>Another approach is to compress the texture into video memory and decompress it into a local cache on the accelerator. This decreases the video memory bandwidth required to keep the rasterizer running at full speed. In DirectX 5.0, drivers could do this as well, but it is a much slower operation that affects the application's view of video memory allocation due to the resulting smaller texture.</P>

<P>To accommodate hardware vendors, DirectX 6.0 and later versions enable “optimized” textures that give the driver an opportunity to translate the surface into a proprietary format when the texture is used. Once optimized, the surface cannot be locked and may be smaller or larger than the original.</P>

<P>Many 3D accelerator chipsets on the market have a proprietary format that cannot be described with the standard DirectDraw mechanisms. This feature is intended to cover all hardware with such surface types. </P>

<P>Currently applications have some textures that must be updated frequently, and others that can be left alone for the duration of the application. These latter benefit from patching due to improved resulting fill rate. The flags shown in the <A HREF="d3d_3nl3.htm">Optimized Texture API</A> section allow the application to specify this usage scenario to the driver so it can optimize performance accordingly.</P>
<DIV CLASS="footer"><A HREF="mailto:ddksurv1@microsoft.com?subject=DDK Topic Feedback&body=Build date: Thursday, January 16, 2003     Topic Title: Optimized%20Textures"> Send feedback on this topic.</A> / Built on Thursday, January 16, 2003 </DIV>
</BODY>
</HTML>
