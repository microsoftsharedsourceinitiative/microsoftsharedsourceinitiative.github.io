<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Dot commands</TITLE>
<SCRIPT SRC="../scripts/linkcss.js"></SCRIPT><SCRIPT SRC="../scripts/langref.js"></SCRIPT><META NAME="MS-HKWD" CONTENT="Dot commands">
</HEAD>
<BODY TOPMARGIN="0">

<TABLE CLASS="buttonbarshade" CELLSPACING=0><TR><TD>&nbsp;</TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING=0>
<TR ID="hdr"><TD CLASS="runninghead" NOWRAP>Windows&nbsp;98/Me:&nbsp;Windows&nbsp;DDK</TD></TR>
</TABLE>
<H3><A NAME="ddk_dot_commands_me"></A>Dot commands</H3>

<P>Dot commands are commands that are directed to the debugger entry point of a corresponding VxD. “System dot commands” are those commands that are always available.  There are dot commands for several debug binary VxDs.  The “Required debug binary .VxD” column indicates the debug binary that must be loaded to use the corresponding dot command(s).  Many of the following debugger dot commands first require the installation of their corresponding debug binary VXD version.  The following system dot commands are applicable to Windows 9x Version B (OSR2), but are generally the same for Golden Windows 9x.</P>

<TABLE>

<TR VALIGN="top">
<TH align=left width=23%>Command</TH>
<TH align=left width=24%>Additional Argument(s)</TH>
<TH align=left width=23%>Required debug binary .VxD</TH>
<TH align=left width=30%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=23%><B>..&lt;cmd&gt; </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%> -</TD>
<TD width=30%>Pass "cmd" directly to the VMM</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.? </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Prints help message</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.&lt;dev_name&gt; </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%> -</TD>
<TD width=30%>Display device (VxD) specific info (if supported by the VxD)</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>..BIOS</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>BIOS</TD>
<TD width=30%>BIOS (space for help)?<BR>
<B>a </B><B>—</B><B> </B>Show all BIOS devnodes<BR>
<B>e</B> — Dump recent BIOS events<BR>
<B>l </B><B>—</B><B> </B>Show List (Show every PCI devnode)<BR>
<B>s </B><B>—</B><B> </B>Show selected devnode<BR>
<B>y </B><B>—</B><B> </B>Select devnode<BR>
<B>z </B><B>—</B><B> </B>Select devnode by index</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.CSP </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>VMM</TD>
<TD width=30%>Toggles catch stray pointer flag</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DF </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dumps the free list</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DG </B></TD>
<TD width=24%>[handle | selector | arena(386)]</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dumps the global heap</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DH </B></TD>
<TD width=24%>[0 (from top) | -1 (from bottom)] </TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dumps the local heap</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DM </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dumps the Win16 module list</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DOSMGR</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>-</TD>
<TD width=30%>Dumps various data structures related to real-mode DOS.
<UL>
	<LI>Display SFTs</LI>

	<LI>Display DPBs</LI>

	<LI>Display MCBs (dump the real-mode memory map)</LI>

	<LI>Display CDSs</LI>

	<LI>Display PDBs (dump the real-mode process map)</LI>

	<LI>Display DEVs</LI>

	<LI>Display BDSs</LI>

	<LI>Display INT 21h status</LI>
</UL>
</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DQ </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dumps the task queue</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DS </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dumps protected mode stack with labels. Dumps the VMM stack.  Shows the stack pointer value, the DWORD contents and tries to display a code label that is near to each DWORD  value. The label dump is sometimes useful for determining what chain of procedures have been executed to get to the current point, but it  sometimes displays labels for DWORD values that really don't apply  (i.e. 80000028 might display VMM_TEXT:DEBUG_ValidateLinear, when the  value may really be from pushing the segment value 28, because pushing a segment value just decrements ESP and doesn't force a zero word for the high word.)  So, this command can be useful, but requires some programmer interpretation to identify the correct stack trace.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.DU </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dumps the LRU list</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.I?</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>IOS</TD>
<TD width=30%>Help menu for IOS commands</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.IDCB</B></TD>
<TD width=24%>&lt;addr&gt;</TD>
<TD width=23%>IOS</TD>
<TD width=30%>Dumps I/O Subsystem Device Control Block structure.  </TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.IIOP </B></TD>
<TD width=24%>&lt;addr&gt;</TD>
<TD width=23%>IOS</TD>
<TD width=30%>Dumps I/O Subsystem I/O Packet structure.  </TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.IMED</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>IOS</TD>
<TD width=30%>Dumps I/O Subsystem Memory Element Descriptor structures. </TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.IDV</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>DISKVSD &amp; IOS</TD>
<TD width=30%>Display disk calldown/callup statistics</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.ISAPNP</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>ISAPNP</TD>
<TD width=30%>Display current read data port, followed by information about each ISA bus card (if any).</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.LQ </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>VMM</TD>
<TD width=30%>Displays the queue of messages queued with the macro Queue_Out. </TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.M </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Dump assorted memory manager structures.  Type '.M?' for a list of memory structures, and additional information.  </TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.MEMCHECK</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>-</TD>
<TD width=30%>Display misc. memory layout</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.NTKERN</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>NTKERN</TD>
<TD width=30%>OSR 2.1 &amp; Windows 9x NT WDM (USB etc.) support.  Typing this command supplies you with a menu, which includes the ability to dump its debug log (“D”).  The debug log displays in LIFO order.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.P</B></TD>
<TD width=24%>[?]</TD>
<TD width=23%>DEBUGCMD</TD>
<TD width=30%>Debugger tools when DEBUGCMD.VXD is installed (rename DEBUGCMD.TMP to DEBUGCMD.VXD, place it into \WINDOWS\SYSTEM, and load it by putting DEVICE=DEBUGCMD.VXD in the [386Enh] section of the SYSTEM.INI file):<BR>
<B>.p? </B><B>—</B><B> </B>Main help menu
<P><B>.p&lt;cmd&gt;? </B><B>—</B><B> </B>For more extensive help on a cmd</P>

<P><B>.p </B><B>—</B><B> </B>lists threads in system</P>

<P><B>.p &lt;*/thread id&gt;</B> — lists status of one thread</P>

<P><B>.pf  </B><B>—</B><B> </B>lists threads and their flags</P>

<P><B>.ps &lt;Thread handle/id&gt; </B><B>—</B><B> </B>Dumps ring 0 stack with labels</P>

<P><B>.psx &lt;Thread handle/id&gt;</B>Dumps 20 lines of ring0 stack and returns</P>

<P><B>.pdev &lt;Address&gt; </B><B>—</B><B> </B>Finds nearest VXD name</P>

<P><B>.plog &lt;flags&gt;</B>Set scheduler query logging flags</P>

<P><B>.pmtx &lt;Mutex Address&gt; </B><B>—</B><B> </B>display mutex state</P>

<P><B>.psem &lt;Semaphore Address&gt;</B>display semaphore state</P>

<P><B>.pthcb &lt;Thread handle/id&gt; </B><B>—</B><B> </B>display thread control block</P>

<P><B>.pprd</B>Disables the logging of priority changes</P>

<P><B>.ppre </B><B>—</B><B> </B>Enables the logging of priority changes</P>

<P><B>.pprf &lt;filter&gt; </B><B>—</B><B> </B>Logs only boosts changing these bits</P>

<P><B>.pprl &lt;Thread handle/id&gt; </B><B>—</B><B> </B>Lists priority changes recorded</P>

<P><B>.pmax </B><B>—</B><B> </B>Show thread and VM maximum DOS386 stack usage</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.PCI</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>PCI</TD>
<TD width=30%>PCI debug utility.  Note that to use .PCI you must remove debugcmd.vxd from the system because its .P command prevents .PCI from being recognized.<BR>
“Welcome to PCI's debugger”<BR>
<B>A </B><B>—</B><B> </B>show All; Show every PCI devnodes
<P><B>B </B><B>—</B><B> </B>show Busses; Show PCI bus structure</P>

<P><B>C </B><B>—</B><B> </B>Config space; Toggle full/partial        config space</P>

<P><B>D </B><B>—</B><B> </B>Enter dwdata; Enter data in config        space in dwords</P>

<P><B>E </B><B>—</B><B> </B>Enter data; Enter data in config space</P>

<P><B>F </B><B>—</B><B> </B>FindIRQRoute; Help find the IRQ routing</P>

<P><B>G </B><B>—</B><B> </B>Global info; Show global PCI info</P>

<P><B>I </B><B>—</B><B> </B>IDE Test; See if secondary IDE is enabled</P>

<P><B>L </B><B>—</B><B> </B>show List; Show every PCI devnodes  (short)</P>

<P><B>Q </B><B>—</B><B> </B>Quit; Quit the debugger</P>

<P><B>R </B><B>—</B><B> </B>show Rom; Show ROM of selected devnode</P>

<P><B>S </B><B>—</B><B> </B>Show selected; Show selected devnode</P>

<P><B>T </B><B>—</B><B> </B>Trace CS; Trace config space access</P>

<P><B>Y </B><B>—</B><B> </B>select devnode; Select DevNode</P>

<P><B>Z </B><B>—</B><B> </B>select devnode; Select DevNode by index</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.R </B></TD>
<TD width=24%>[#] </TD>
<TD width=23%>-</TD>
<TD width=30%>Displays the registers of the current thread.  For example, if you used &lt;ctrl c&gt; to break into the system, this will show you the debugger’s &lt;ctrl c&gt; handler.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.REBOOT </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>reboots machine</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.S  </B></TD>
<TD width=24%>[#]</TD>
<TD width=23%>VMM</TD>
<TD width=30%>Displays short logged exceptions starting at #, if specified.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.SL </B></TD>
<TD width=24%>[#]</TD>
<TD width=23%>VMM</TD>
<TD width=30%>Displays long logged exceptions just #, if specified. </TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.T  </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>VMM</TD>
<TD width=30%>Toggles the trace switch. </TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VC</B></TD>
<TD width=24%>[#] ------ </TD>
<TD width=23%>(system)</TD>
<TD width=30%>Displays the current VMs control block</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VDMAD</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>VDMAD</TD>
<TD width=30%>Virtual DMA Device State Dump</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VDD</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>VDD</TD>
<TD width=30%>Virtual Display Device State Dump.  Also offers additional options:<BR>
1 — display VM register states<BR>
2 — display VM memory usage<BR>
3 — dump video page info<BR>
4 — display msg mode register state<BR>
5 — display planar mode register state<BR>
6 — read DAC<BR>
7 — display VM DAC states<BR>
8 — enable Queue_Outs<BR>
9 — enable MemC debug event</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VFLATD</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>VFLATD</TD>
<TD width=30%>Virtual Flat Video Buffer Device statistics and event log</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VH </B></TD>
<TD width=24%>[#] ------ </TD>
<TD width=23%>(system)</TD>
<TD width=30%>Displays a VMM linked list, given list handle</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VKD</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>VKD</TD>
<TD width=30%>Virtual Keyboard Device<BR>
[0] — General info<BR>
[1] — Hot Key info<BR>
[2] — Per VM info<BR>
[3] — Set VKD queue_outs<BR>
[ESC] — Exit VKD debug query</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VL </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Displays a list of all valid VM handles</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VM </B></TD>
<TD width=24%>[#] ------ </TD>
<TD width=23%>(system)</TD>
<TD width=30%>Displays complete VM status</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VMM </B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>(system)</TD>
<TD width=30%>Menu VMM state information:<BR>
[A] — System time<BR>
[B] — Display Critical Section info<BR>
[C] — Display blocked thread information<BR>
[D] — Reset dyna-link profile counts<BR>
[E] — I/O port trap information<BR>
[F] — Reset I/O profile counts<BR>
[G] — Turn procedure call trace logging on<BR>
[H] — V86 interrupt hook information<BR>
[I] — PM interrupt hook information<BR>
[J] — Reset PM and V86 interrupt profile counts<BR>
[K] — Display event lists<BR>
[L] — Display device list (all VxDs)<BR>
[M] — Display V86 break points<BR>
[N] — Display PM break points<BR>
[O] — Display interrupt profile<BR>
[P] — Reset interrupt profile counts<BR>
[Q] — Display GP fault profile<BR>
[R] — Reset GP fault profile counts<BR>
[S] — Toggle verbose device call trace<BR>
[T] — Dyna-link service profile information<BR>
[U] — Fault Hook information<BR>
[V] — Display time out queues<BR>
[W] — PM CLI/STI trace info<BR>
[X] — DPMI info</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VPICD</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>-</TD>
<TD width=30%>Virtual PIC Device status (status of hardware interrupts)<BR>
[1] — Global PIC information (ring 0)<BR>
[2] — Per-VM PIC information (virtualized VM state)<BR>
[3] — IRQ handler information (hardware interrupts and who is responsible for each)</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VR </B></TD>
<TD width=24%>[#] ------ </TD>
<TD width=23%>(system)</TD>
<TD width=30%>Displays the registers of the current VM (both the current and alternate registers).  Used to examine both V86 mode and protected mode portions of the VM.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VS </B></TD>
<TD width=24%>[#] ------ </TD>
<TD width=23%>(system)</TD>
<TD width=30%>Displays the current VM's virtual mode stack</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.VXDLDR</B></TD>
<TD width=24%>&nbsp;</TD>
<TD width=23%>-</TD>
<TD width=30%>Displays the list of dynamically loaded devices</TD>
</TR>

<TR VALIGN="top">
<TD width=23%><B>.Y</B></TD>
<TD width=24%>&lt;expr&gt;</TD>
<TD width=23%>CONFIGMG</TD>
<TD width=30%>Displays CONFIGMG (Plug &amp; Play) structures:<BR>
Welcome to CONFIGMG's debugger<BR>
A (Arbitrators) — Show the list of arbitrators<BR>
B (Block queue) — Prevent processing of events<BR>
C (Query remove) — Query removal at happy time<BR>
d (remove) — Removal at happy time<BR>
e (toggle Echo) — Set the echo to a specified level<BR>
f (show Free) — Show free resources<BR>
g (enumerate) — Enumerate a devnode<BR>
h (Reenable Appy) — Reenable checking of query remove<BR>
i (Show Log) — Show procedural logs<BR>
j (test walks) — Test our walk procedures<BR>
k (Show stack) — Show stack of procedure logs<BR>
l (show List) — Show devnode list<BR>
m (screen size) — Set screen size<BR>
n (Nuke logs) — Nuke the procedure logged<BR>
p (Problem) — List devnodes with problems<BR>
q (Quit) — Quit the debugger<BR>
r (show Range) — Show a Range<BR>
s (Show tree) — Show the hardware tree<BR>
t (toggle time) — Toggle the display of time<BR>
u (Unblock queue) — Restart processing of events<BR>
v (View status) — View the global status of CONFIGMG<BR>
w (show all range) — Show all the rangelists<BR>
x (eXclude) — Filter logging of procedure logs<BR>
y (force smthng) — Call some random HWProfile API<BR>
z (Allow DLL call) — Allow the DLLs to be called</TD>
</TR>
</TABLE><BR>

<P>Where…</P>

<P class=indent1>&lt;range&gt; = [&lt;addr&gt;] [&lt;word&gt;] | &lt;addr&gt; [L &lt;word&gt;]</P>

<P class=indent1>&lt;addr&gt; = [&amp; | #][&lt;word&gt;:]&lt;word&gt; | %&lt;dword&gt; | %%&lt;dword&gt;</P>

<P class=indent1>&lt;list&gt; = &lt;byte&gt; &lt;byte&gt; ... | "string"</P>

<P class=indent1>&lt;binary ops&gt; = : | * / MOD + . - &lt;&lt; &gt;&gt; &lt; &gt; &gt;= &lt;= AND XOR OR &amp;&amp; ||</P>

<P class=indent1>&lt;unary ops&gt; = &amp;seg #sel %lin %%phy ! NOT SEG OFF BY WO DW POI PORT WPORT</P>

<P class=indent1>(OFF=offset, BY=byte, WO=word/16-bit near proc, DW=dword/32-bit proc, POI=16-bit FAR addr, PORT=I/O byte port, WPORT=I/O word port)</P>

<P>Regular expressions &lt;re&gt;:</P>

<P class=indent1>. any character, [] character class, [a-z], [^a], etc</P>

<P class=indent1>* match zero or more, # match zero or one, + match one or more</P>

<P>Supported printf format characters are:</P>

<TABLE>

<TR VALIGN="top">
<TH align=left width=50%>Character</TH>
<TH align=left width=50%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=50%>%%</TD>
<TD width=50%>%</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%c</TD>
<TD width=50%>character</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][+][ ][0][width][.precision][p][n]d</TD>
<TD width=50%>decimal</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][0][width][.precision][p][n]u</TD>
<TD width=50%>unsigned decimal</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][#][0][width][.precision][p][n]x</TD>
<TD width=50%>hex</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][#][0][width][.precision][p][n]X</TD>
<TD width=50%>hex</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][0][width][.precision][p][n]o</TD>
<TD width=50%>octal</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][0][width][.precision][p][n]b</TD>
<TD width=50%>binary</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][width][.precision][a]s</TD>
<TD width=50%>string</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][width][.precision][a][p][n][L][H][N][Z]A</TD>
<TD width=50%>address</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][width][.precision][a][p][n][L][H][N][Z]S</TD>
<TD width=50%>symbol</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][width][.precision][a][p][n][L][H][N][Z]G</TD>
<TD width=50%>group:symbol</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][width][.precision][a][p][n][L][H][N][Z]M</TD>
<TD width=50%>map:group:symbol</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][width][.precision][a][p][n][L][H][N][Z]g</TD>
<TD width=50%>group</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%[-][width][.precision][a][p][n][L][H][N][Z]m</TD>
<TD width=50%>map</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>a</TD>
<TD width=50%>pointer to a AddrS structure</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>H</TD>
<TD width=50%>16 bit offset</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>L</TD>
<TD width=50%>32 bit offset</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>N</TD>
<TD width=50%>offset only</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>Z</TD>
<TD width=50%>no address</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>p</TD>
<TD width=50%>gets the previous symbol, address or offset</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>n</TD>
<TD width=50%>gets the next symbol, address or offset</TD>
</TR>
</TABLE><BR>

<P>Prompts are:</P>

<P class=indent1>&gt; real mode</P>

<P class=indent1>- or -- virtual 8086 mode</P>

<P class=indent1># or ## protected mode</P>
<DIV CLASS="footer"><A HREF="mailto:ddksurv1@microsoft.com?subject=DDK Topic Feedback&body=Build date: Thursday, January 16, 2003     Topic Title: Dot%20commands"> Send feedback on this topic.</A> / Built on Thursday, January 16, 2003 </DIV>
</BODY>
</HTML>
