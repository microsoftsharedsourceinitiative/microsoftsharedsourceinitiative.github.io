<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>DEBUGGER.EXE Command Details</TITLE>
<SCRIPT SRC="../scripts/linkcss.js"></SCRIPT><SCRIPT SRC="../scripts/langref.js"></SCRIPT><META NAME="MS-HKWD" CONTENT="DEBUGGER.EXE Command Details">
</HEAD>
<BODY TOPMARGIN="0">

<TABLE CLASS="buttonbarshade" CELLSPACING=0><TR><TD>&nbsp;</TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING=0>
<TR ID="hdr"><TD CLASS="runninghead" NOWRAP>Windows&nbsp;98/Me:&nbsp;Windows&nbsp;DDK</TD></TR>
</TABLE>
<H3><A NAME="ddk_debugger.exe_command_details_me"></A>DEBUGGER.EXE Command Details</H3>

<P>The following is a list of DEBUGGER.EXE’s commands.</P>

<H1>? (Help) </H1>

<P>The <B>?</B> command with no arguments displays a list of commands and syntax recognized by the debugger. </P>

<H1>? (Evaluate Expression)</H1>

<P>? [option.]expr</P>

<P>? "string", expr, ...</P>

<P>The <B>?</B> command evaluates an expression and displays the result. 

<DL>
<DT><I>expr </I></DT>

<DD>Expression to evaluate. Can be a combination of numbers, addresses, and operators. Numbers are assumed to be hexadecimal. Addresses can be 32-bit physical addresses or protected-mode addresses (selector:offset). The number sign (#) operator overrides the current address type. Operators can be any listed in Binary and Unary Operators. </DD>

<DT><I>option </I></DT>

<DD>Format in which to display the expression. Can be one of these: 

<TABLE>

<TR VALIGN="top">
<TD width=50%><B>h. </B></TD>
<TD width=50%>Hexadecimal </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>d. </B></TD>
<TD width=50%>Decimal </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>t. </B></TD>
<TD width=50%>Decimal </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>o. </B></TD>
<TD width=50%>Octal </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>q. </B></TD>
<TD width=50%>Octal </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>y. </B></TD>
<TD width=50%>Binary </TD>
</TR>
</TABLE><BR>



<P>By default, the command displays all formats: decimal, hexadecimal, octal, binary, ASCII, and Boolean. 
</DD>

<DT><I>string </I></DT>

<DD>Formatting string. Can be a combination of text and zero or more of the following formatting descriptors and escape sequences: 

<TABLE>

<TR VALIGN="top">
<TD width=50%>%% </TD>
<TD width=50%>Displays a percent sign (%). </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%A </TD>
<TD width=50%>Displays matching expr as an address. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%b </TD>
<TD width=50%>Displays matching expr in binary format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%c </TD>
<TD width=50%>Displays matching expr as a character. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%d </TD>
<TD width=50%>Displays matching expr in decimal format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%G </TD>
<TD width=50%>Evaluates matching expr as an address and displays the group and symbol associated with the address in group:symbol format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%M </TD>
<TD width=50%>Evaluates matching expr as an address and displays the map file, group and symbol associated with the address in map:group:symbol format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%o </TD>
<TD width=50%>Displays matching expr in octal format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%S </TD>
<TD width=50%>Evaluates matching expr as an address and displays the map file, group and symbol associated with the address. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%s </TD>
<TD width=50%>Evaluates matching expr as an address and displays the string at that address. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%u </TD>
<TD width=50%>Displays matching expr in unsigned decimal format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%X </TD>
<TD width=50%>Displays matching expr in hexadecimal format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>%x </TD>
<TD width=50%>Displays matching expr in hexadecimal format </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>\a </TD>
<TD width=50%>Inserts a bell (alert) character. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>\b </TD>
<TD width=50%>Inserts a backspace character. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>\n </TD>
<TD width=50%>Inserts a new line character. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>\r </TD>
<TD width=50%>Inserts a carriage return character. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>\t </TD>
<TD width=50%>Inserts a horizontal tab character. </TD>
</TR>
</TABLE><BR>



<P>One expression must be given for each formatting descriptor in the string. Multiple expressions can be separated with commas (,) or spaces. 

</DD>
</DL>

<P>Formatting descriptors can have these optional prefixes: </P>

<TABLE>

<TR VALIGN="top">
<TD width=50%>A </TD>
<TD width=50%>[-][width][.precision][a][p][n][L][H][N] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>b </TD>
<TD width=50%>[-][0][width][.precision][p][n] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>d </TD>
<TD width=50%>[-][+][ ][0][width][.precision][p][n] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>G </TD>
<TD width=50%>[-][width][.precision][a][p][n][L][H][N] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>M </TD>
<TD width=50%>[-][width][.precision][a][p][n][L][H][N] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>o </TD>
<TD width=50%>[-][0][width][.precision][p][n] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>s </TD>
<TD width=50%>[-][width][.precision][a] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>S </TD>
<TD width=50%>[-][width][.precision][a][p][n][L][H][N] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>u </TD>
<TD width=50%>[-][0][width][.precision][p][n] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>X </TD>
<TD width=50%>[-][#][0][width][.precision][p][n] </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>x </TD>
<TD width=50%>[-][#][0][width][.precision][p][n] </TD>
</TR>
</TABLE><BR>

<P>Specifying an asterisk (*) for the width or precision parameter causes the field width or precision, respectively, to be picked up from the next parameter. Decimal values can also be specified for the width and precision parameters. The prefix letters have these meanings: </P>

<TABLE>

<TR VALIGN="top">
<TH align=left width=50%>Prefix</TH>
<TH align=left width=50%>Meaning</TH>
</TR>

<TR VALIGN="top">
<TD width=50%>a </TD>
<TD width=50%>Address argument size </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>H </TD>
<TD width=50%>Display 16-bit offset </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>L </TD>
<TD width=50%>Display 32-bit offset </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>N </TD>
<TD width=50%>Display offset only </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>p </TD>
<TD width=50%>Get the previous symbol, symbol address, or offset </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>n </TD>
<TD width=50%>Get the next symbol, symbol address, or offset </TD>
</TR>
</TABLE><BR>

<P>The following examples show simple commands and corresponding output: </P>

<P class=indent1>? ds:esi</P>

<P class=indent1>013f:000001B3 %00098953 %%00098953</P>

<P class=indent1>// display the value of the arithmetic expression 3*4: </P>

<P class=indent1>? 3*4</P>

<P class=indent1>0Ch 12T 14Q 00001100Y '.' TRUE</P>

<H1>bc (Breakpoint Clear) </H1>

<P>bc list | *</P>

<P>The <B>bc</B> command removes one or more defined breakpoints. 

<DL>
<DT><I>list </I></DT>

<DD>Specifies any combination of integer values in the range 0 through 9. If you specify list, the debugger removes the specified breakpoints. </DD>

<DT><I>* </I></DT>

<DD>Clears all breakpoints. 
</DD>
</DL>

<P>This example removes breakpoints 0, 4, and 8: </P>

<P>bc 0 4 8</P>

<H1>bd (Breakpoint Disable) </H1>

<P>bd list | *</P>

<P>The <B>bd </B>command temporarily disables one or more breakpoints. To restore breakpoints disabled by the <B>bd</B> command, use the <B>be</B> (Breakpoint Enable) command. 

<DL>
<DT><I>list </I></DT>

<DD>Specifies any combination of integer values in the range 0 through 9. If you specify list, the debugger disables the specified breakpoints. </DD>

<DT><I>* </I></DT>

<DD>Disables all breakpoints. 
</DD>
</DL>

<P>This example disables breakpoints 0, 4, and 8: </P>

<P class=indent1>bd 0 4 8</P>

<H1>be (Breakpoint Enable) </H1>

<P>be list | *</P>

<P>The <B>be</B> command restores (enables) one or more breakpoints that have been temporarily disabled by a <B>bd</B> (Breakpoint Disable) command. 

<DL>
<DT><I>list </I></DT>

<DD>Specifies any combination of integer values in the range 0 through 9. If you specify list, the debugger enables the specified breakpoints. </DD>

<DT><I>* </I></DT>

<DD>Enables all breakpoints. 
</DD>
</DL>

<P>This example enables breakpoints 0, 4, and 8: </P>

<P class=indent1>be 0 4 8</P>

<H1>bl (Breakpoint List) </H1>

<P>bl</P>

<P>The <B>bl</B> command lists current information about all breakpoints created by the <B>bp</B> (Breakpoint) command. For each existing breakpoint, the command displays the breakpoint number, the enabled status ('e' for enabled, 'd' for disabled, 'I' for invalid), the breakpoint address, the number of passes remaining (if any), the initial number of passes in parentheses (if any), and debugger commands to be executed when the breakpoint is reached (if any). An invalid “I” breakpoint typically indicates the code has been paged out to disk; it may come back later. You can’t remove an invalid breakpoint until it pages back in.</P>

<P>The following example shows a typical list: </P>

<P class=indent1>0 d  %004010b5 [_MyTest] 4 (10) "db ds:edi"</P>

<P class=indent1>1 eI %0040110f [_MyWndProc@16 + 5a]</P>

<H1>bp (Breakpoint) </H1>

<P>bp[number]addr [count] ["cmds"]</P>

<P>The <B>bp</B> command creates a software breakpoint at an address. When the application is running, software breakpoints stop execution and force the debugger to execute the default or optional command string. Unlike breakpoints created by the <B>g</B> (Go) command, software breakpoints remain in memory until you remove them with the <B>bc</B> (Breakpoint Clear) command or temporarily disable them with the <B>bd</B> (Breakpoint Disable) command. 

<DL>
<DT><I>number </I></DT>

<DD>Specifies which breakpoint is being created. No space is allowed between the <B>bp</B> and number. If number is omitted, the first available breakpoint number is used. The debugger allows up to 10 software breakpoints (0 through 9). If you specify more than 10 breakpoints, the debugger returns the message: "Too Many Breakpoints." </DD>

<DT><I>addr </I></DT>

<DD>Specifies any valid instruction address — the first byte of an operation code (opcode). The addr parameter is required for all new breakpoints. </DD>

<DT><I>count </I></DT>

<DD>Specifies the number of times the breakpoint is to be ignored before being executed. It can be any 16-bit value. </DD>

<DT><I>cmds </I></DT>

<DD>Specifies an optional list of debugger commands to be executed in place of the default command when the breakpoint is reached. You must enclose optional commands in quotation marks and separate optional commands with semicolons (;). 
</DD>
</DL>

<P>This example creates a breakpoint at address CS:401000: </P>

<P class=indent1>bp 401000</P>

<P>This example creates breakpoint 8 at address given by the symbol _MyTest. When the breakpoint occurs, the debugger displays bytes at DS:SI: </P>

<P class=indent1>bp8 _MyTest "db DS:SI"</P>

<P>You cannot set a breakpoint on memory that is not in context (however, you can set a hardware execution breakpoint on the linear address; see the br command).</P>

<H1>br (Breakpoint Register) </H1>

<P>br [number] flags [addr] [count] ["cmds"]</P>

<P>The Pentium processor contains four “hardware debug registers” that support hardware address breakpoints. Hardware debug registers allow the user to instruct the processor hardware to interrupt processor execution when specified addresses are read, written or executed. This is a very useful tool, for example, to find out what procedures are accessing or changing a specified memory variable.</P>

<P>The <B>br</B> command sets a Pentium debug register breakpoint, in order to “break” on data reads, writes and instruction execution. Up to four debug registers can be set and enabled at one time. </P>

<P>Hardware breakpoints take precedence over faults.</P>

<P>Since the four debug registers are global to the system, they should typically only be touched by a kernel mode debugger. See Knowledge Base Article Q137199, “ PRB: Debuggers Cannot Reliably Use Debug Register Breakpoints” for more information.</P>

<P>See also the following MSDN Library CD article: Q105275, “Using the ‘BR’ Command in DEBUGGER.EXE.EXE”.

<DL>
<DT><I>number </I></DT>

<DD>Specifies which breakpoint is being created. No space is allowed between the <B>br</B> command and the number parameter. If number is omitted, the first available breakpoint number is used. </DD>

<DT><I>flags </I></DT>

<DD>Specifies the length and break conditions for the breakpoint. This parameter can be some combination of the following values: 

<TABLE>

<TR VALIGN="top">
<TH align=left width=50%>Value</TH>
<TH align=left width=50%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=50%><B>1 </B></TD>
<TD width=50%>Set 1-byte length (default value). </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>2 </B></TD>
<TD width=50%>Set word length on word boundary. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>4 </B></TD>
<TD width=50%>Set doubleword length on doubleword boundary. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>E </B></TD>
<TD width=50%>Break on instruction execution only (1-byte length only). </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>W </B></TD>
<TD width=50%>Break on writes only. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>R </B></TD>
<TD width=50%>Break on reads and writes. </TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>addr</I></DT>

<DD>Specifies the address to be watched.</DD>

<DT><I>count </I></DT>

<DD>Specifies the number of times the breakpoint is to be ignored before being executed. It can be any 16-bit value. </DD>

<DT><I>cmds </I></DT>

<DD>Specifies an optional list of debugger commands to be executed in place of the default command when the breakpoint is reached. You must enclose the group of optional commands in quotation marks and separate optional commands with semicolons (;). 
</DD>
</DL>

<H1>c (Compare) </H1>

<P>c range addr</P>

<P>The <B>c</B> command compares one memory location with another memory location. If the two memory areas are identical, the debugger displays nothing and returns the debugger prompt. Differences, when they exist, are displayed in this form: addr1 byte1 byte2 addr2. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory that is to be compared with a block of memory starting at addr. </DD>

<DT><I>addr </I></DT>

<DD>Specifies the starting address of the second block of memory. 
</DD>
</DL>

<P>This example compares the bytes at addresses in the range 100h to 1FFh with the corresponding bytes at address from 300h to 3FFh: </P>

<P class=indent1>c100 1FF 300</P>

<P>This example compares the same block of memory as the previous example but specifies the range by using the <B>L</B> (length) option. </P>

<P class=indent1>c100 L 100 300</P>

<H1>d (Display) </H1>

<P>d [range]</P>

<P>The <B>d</B> command displays the contents of memory at a given address or in a range of addresses. The <B>d</B> command displays one or more lines, depending on the range given. Each line displays the address of the first item displayed. The command always displays at least one value. The memory display is in the format defined by a previously executed <B>da</B>, <B>db</B>, <B>dd</B>, or <B>dw</B> command. Each subsequent <B>d</B> (typed without parameters) displays the bytes immediately following those last displayed. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory to display. If you omit range, the <B>d</B> command displays the next byte of memory after the last one displayed. The <B>d</B> command must be separated by at least one space from any range value. 
</DD>
</DL>

<H1>da (Display ASCII) </H1>

<P>da [range]</P>

<P>The <B>da</B> command displays as ASCII characters the values of the bytes at a given address or in a given range. The display includes all bytes up to the first zero byte. Nonprinting characters and characters having values greater than 127 are denoted by a period (.). </P>

<H1>db (Display Bytes) </H1>

<P>db [range]</P>

<P>The <B>db</B> command displays the values of the bytes at a given address or in a given range. </P>

<P>The display is in two portions: a hexadecimal display (each byte is shown in hexadecimal format) and an ASCII display (the bytes are shown as ASCII characters). A nonprinting character is denoted by a period (.) in the ASCII portion of the display. Each display line shows 16 bytes, with a hyphen between the eighth and ninth bytes. Each displayed line begins on a 16-byte boundary. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory to display. If you omit range, 128 bytes are displayed beginning at the first address after the address displayed by the previous <B>db</B> command. 
</DD>
</DL>

<P>The following example displays 0Ah bytes of memory, beginning at the specified address: </P>

<P class=indent1>db CS:100 0A</P>

<P>This example displays lines in a format similar to the following: </P>

<P class=indent1>04BA:00000100 54 4F 4D 20 53  . . . 45 52 TOM SAWYER</P>

<P>Each line of the display begins with an address, incremented by 10h from the address on the previous line. </P>

<H1>dd (Display Doublewords) </H1>

<P>dd [range]</P>

<P>The <B>dd</B> command displays the hexadecimal values of the doublewords at the address specified or in the specified range of addresses. The <B>dd</B> command displays one or more lines, depending on the range given. Each line displays the address of the first doubleword in the line, followed by up to four hexadecimal doubleword values. The hexadecimal values are separated by spaces. The <B>dd</B> command displays values up to the end of the range or until the first 32 doublewords have been displayed. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory to display. If you omit range, 32 doubleword values are displayed beginning at the first address after the address displayed by the previous <B>dd</B> command. 
</DD>
</DL>

<P>The following example displays the doubleword values from CS:100 to CS:110: </P>

<P class=indent1>dd CS:100 110</P>

<P class=indent1>04BA:0100 7473:2041 676E:6972 5405:0104 0A0D:7865</P>

<P class=indent1>04BA:0110 0000:002E</P>

<P>No more than four values per line are displayed. </P>

<H1>dg (Display GDT) </H1>

<P>dg[a] [range]</P>

<P>The <B>dg</B> command displays the specified range of entries in the global descriptor table (GDT). 

<DL>
<DT><B>a</B></DT>

<DD>Displays all entries in the table, not just the valid ones. By default, only the valid GDT entries are displayed. If range specifies a local descriptor table (LDT) selector, the command displays the appropriate LDT entry. </DD>

<DT><I>range </I></DT>

<DD>Specifies the range of entries to be displayed. If you omit range, the entire table is displayed. 
</DD>
</DL>

<P>The command displays the selector, descriptor type, base address, limit, privilege, and other descriptor flags. </P>

<H1>di (Display IDT) </H1>

<P>di[a] [range]</P>

<P>The <B>di</B> command displays the specified range of entries in the interrupt descriptor table (IDT). 

<DL>
<DT><B>a </B></DT>

<DD>Displays all entries in the table, not just the valid ones. </DD>

<DT><I>range </I></DT>

<DD>Specifies the range of entries to be displayed. If you omit range, the entire table is displayed. 
</DD>
</DL>

<P>The command displays the interrupt number, the interrupt type, the interrupt address, privilege, and descriptor flags. </P>

<H1>dl (Display LDT) </H1>

<P>dl[a | p | s | h] [range]</P>

<P>The <B>dl</B> command displays the specified range of entries in the local descriptor table (LDT). 

<DL>
<DT><B>a </B></DT>

<DD>Displays all entries in the table, not just the valid ones. By default, only the valid LDT entries are displayed. If range specifies a global descriptor table (GDT) selector, it displays the appropriate GDT entry. </DD>

<DT><B>p </B></DT>

<DD>Displays private segment selectors. </DD>

<DT><B>s </B></DT>

<DD>Displays shared segment selectors. </DD>

<DT><B>h </B></DT>

<DD>Displays huge segment selectors. To display the huge segment selectors, give the shadow selector followed by the maximum number of selectors reserved for that segment plus 1. </DD>

<DT><I>range </I></DT>

<DD>Specifies the range of entries to be displayed. If you omit range, the entire table is displayed. 
</DD>
</DL>

<P>The command displays the selector, descriptor type, base address, limit, privilege, and other descriptor flags. </P>

<H1>dp (Display Page Directory and Tables) </H1>

<P>dp[a|d] [range]</P>

<P>The <B>dp</B> command displays the page directory and page tables. Page tables are always skipped if the corresponding page directory entry is not present. Page directory entries appear with an asterisk next to the page frame. 

<DL>
<DT><B>a </B></DT>

<DD>Displays all present page directory and page table entries; by default, page directory and page table entries that are zero are skipped. </DD>

<DT><B>d </B></DT>

<DD>Displays only page directory entries. If a count is given as part of the optional range, it will be interpreted as a page directory entry count. </DD>

<DT><I>range </I></DT>

<DD>Specifies the range of linear addresses for page tables. 
</DD>
</DL>

<P>The command displays the entry address, frame, and entry flags. Page directory entries are marked with an asterisk (*). Entry flags have the following meanings: </P>

<TABLE>

<TR VALIGN="top">
<TH align=left width=50%>Entry Flag</TH>
<TH align=left width=50%>Meaning</TH>
</TR>

<TR VALIGN="top">
<TD width=50%>A </TD>
<TD width=50%>Accessed </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>c </TD>
<TD width=50%>clean </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>CD </TD>
<TD width=50%>Cache Disable </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>D </TD>
<TD width=50%>Dirty </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>n </TD>
<TD width=50%>Not-present </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>P </TD>
<TD width=50%>Present </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>r </TD>
<TD width=50%>Read-only </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>s </TD>
<TD width=50%>Supervisor </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>U </TD>
<TD width=50%>User </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>u </TD>
<TD width=50%>Unaccessed </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>W </TD>
<TD width=50%>writeable </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>WT </TD>
<TD width=50%>Write Through </TD>
</TR>
</TABLE><BR>

<H1>dt (Display Task State Segment) </H1>

<P>dt [addr]</P>

<P>The <B>dt</B> command displays the current task state segment (TSS) or the selected TSS if you specify the optional address. More information about the TSS can be found in Intel’s “Pentium Processor User’s Manual, Volume 3” (1993). This command can be useful to view the register state at the time a double-fault occurs (<B>dt 18:0</B>).

<DL>
<DT><I>addr </I></DT>

<DD>Specifies the address of the TSS to display. If no addr is given, <B>dt</B> displays the current TSS pointed to by the TR register. 
</DD>
</DL>

<H1>dw (Display Words) </H1>

<P>dw [range]</P>

<P>The <B>dw</B> command displays the hexadecimal values of the words at a given address or in a given range of addresses. The command displays one or more lines, depending on the range given. Each line displays the address of the first word in the line, followed by up to eight hexadecimal word values. The hexadecimal values are separated by spaces. The command displays values until the end of the range or until the first 64 words have been displayed. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the range of addresses to display. If you omit range, 64 words are displayed beginning at the first address after the address displayed by the previous <B>dw</B> command. 
</DD>
</DL>

<P>The following example displays the word values from CS:100 to CS:110: </P>

<P class=indent1>dw CS:100 110</P>

<P class=indent1>04BA:0100 2041 7473 6972 676E 0104 5404 7865 0A0D</P>

<P class=indent1>04BA:0110 002E</P>

<H1>dx (Display Loadall Buffer) </H1>

<P>dx</P>

<P>Displays the contents of the loadall buffer. </P>

<H1>e (Enter) </H1>

<P>e addr [list]</P>

<P>The <B>e</B> command enters byte values into memory at a specified address. You can specify the new values on the command line or let the debugger prompt you for values. 

<DL>
<DT><I>addr </I></DT>

<DD>Specifies the address of the first byte to be entered. </DD>

<DT><I>list </I></DT>

<DD>Specifies the byte values used for replacement. These values are inserted automatically. If an error occurs when you are using the list form of the command, no byte values are changed. 
</DD>
</DL>

<P>If the debugger prompts you, it displays the address and its contents and then waits for you to perform one of the following actions: 

<UL>
	<LI>Rplace a byte value with a value you type. Type the value after the current value. If the byte you type is an invalid hexadecimal value or contains more than two digits, the system does not echo the illegal or extra character. </LI>

	<LI>Press the SPACEBAR to advance to the next byte. To change the value, type the new value after the current value. If, when you press the SPACEBAR, you move beyond an 8-byte boundary, the debugger starts a new display line with the address displayed at the beginning. </LI>

	<LI>Type a hyphen (-) to return to the preceding byte. If you decide to change a byte before the current position, typing the hyphen returns the current position to the previous byte. When you type the hyphen, a new line is started with its address and byte value displayed. </LI>

	<LI>Press ENTER to terminate the <B>e</B> command. You can press ENTER at any byte position. </LI>
</UL>

<P>The following example prompts you to change the value EB at CS:100: </P>

<P class=indent1>eCS:100</P>

<P class=indent1>04BA:0100 EB.</P>

<P>To step through the subsequent bytes without changing values, press the SPACEBAR. In the following example, the SPACEBAR is pressed three times: </P>

<P class=indent1>04BA:0100 EB.41  10. 00. BC.</P>

<P>To return to a value at a previous address, type a hyphen, as shown in the following example: </P>

<P class=indent1>04BA:0100  EB.41    10. 00. BC.-</P>

<P class=indent1>04BA:0102  00.-</P>

<P class=indent1>04BA:0101  10.</P>

<P>This example returns to the address CS:101. </P>

<H1>f (Fill) </H1>

<P>f range list</P>

<P>The <B>f</B> command fills the addresses in a specified range with the values in the specified list. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory to be filled. If range contains more bytes than the number of values in list, the debugger uses list repeatedly until all bytes in range are filled. If any of the memory in range is not valid (bad or nonexistent), an error occurs in all succeeding locations. </DD>

<DT><I>list </I></DT>

<DD>Specifies the list of values to fill the given range. If list contains more values than the number of bytes in range, the debugger ignores the extra values in list. 
</DD>
</DL>

<P>The following example fills memory locations 04BA:100 through 04BA:1FF with the bytes specified, repeating the five values until it has filled all 100h bytes: </P>

<P class=indent1>f04BA:100 L 100 42 45 52 54 41</P>

<H1>g (Go) </H1>

<P>g[s|h|t|z] [=addr [addr[...]] ]</P>

<P>The <B>g</B> command executes the application currently in memory. If you type the <B>g</B> command by itself, the current application runs as if it had been run outside the debugger. If you specify =addr, execution begins at the specified address. 

<DL>
<DT><B>s </B></DT>

<DD>Shows the time, in microseconds, from when the system is started with gs until the next entry to the debugger. No attempt is made to calculate and remove debugger overhead from the measurement. Requires a timing card.  See MSDN Library CD:  Q85897, “DEBUGGER.EXE-Compatible Timing Card Available”.</DD>

<DT><B>h </B></DT>

<DD>Displays the approximate debugger overhead in the s option. Requires a timing card. </DD>

<DT><B>t </B>or <B>z </B></DT>

<DD>Allows trapped exceptions to resume at the original trap handler address without having to unhook the exception. Use these options instead of the <B>vcp</B> <B>d</B>; <B>t</B>; <B>vsp</B> <B>d</B> commands. Use <B>gt</B> when the debugger catches a fault, in order to continue (resume) execution.</DD>

<DT><I>=addr </I></DT>

<DD>Specifies the address at which execution is to begin. The equal sign (=) is needed to distinguish the starting address from the breakpoint address. </DD>

<DT><I>addr </I></DT>

<DD>Specifies one or more breakpoint addresses where execution is to halt. You can specify up to 10 breakpoints, but only at addresses containing the first byte of an operation code (opcode). If you attempt to set more than 10 breakpoints, an error message is displayed. 
</DD>
</DL>

<P>Specifying an optional breakpoint address causes execution to halt at the first address encountered, regardless of the position of the address in the list of addresses that halts execution or application branching. When execution of the application reaches a breakpoint, the default command string is executed. </P>

<P>The stack (SS:SP) must be valid and have 6 bytes available for this command. The <B>g</B> command uses an <B>iret</B> instruction to cause a jump to the application being tested. The stack is set, and the user flags, CS register, and IP register are pushed on the user stack. (If the user stack is not valid or is too small, the operating system may crash.) An interrupt code (0CCh) is placed at the specified breakpoint addresses. </P>

<P>When the debugger encounters an instruction with the breakpoint code, it restores all breakpoint addresses listed with the <B>g</B> command to their original instructions. If you do not halt execution at one of the breakpoints, the interrupt codes are not replaced with the original instructions. </P>

<P>The following example executes the application currently in memory until address 7550 in the CS selector is executed. The debugger then executes the default command string, removes the <B>int 3</B> trap from this address, and restores the original instruction. When you resume execution, the original instruction is executed. </P>

<P class=indent1>gCS:7550</P>

<P>The command <B>g</B> <B>dw</B> <B>esp</B> can be used to go back to the flat 32-bit calling procedure.</P>

<P>The command <B>g</B> <B>wo</B> <B>ss</B>:<B>sp</B> can be used to go back to the 16-bit near calling procedure.</P>

<P>The command <B>g</B> <B>poi</B> <B>ss</B>:<B>sp</B> can be used to go back to the 16-bit far calling procedure.</P>

<H1>h (Hex) </H1>

<P>h word word</P>

<P>The <B>h</B> command performs hexadecimal arithmetic on the two specified parameters. The debugger adds, subtracts, and multiplies the two parameters; divides the second parameter by the first; and then displays the results on one line. The debugger does 32-bit multiplication and displays the result as doublewords. The debugger displays the result of division as a 16-bit quotient and a 16-bit remainder. 

<DL>
<DT><I>word </I></DT>

<DD>Specifies a 16-bit word parameter. 
</DD>
</DL>

<H1>i (Input) </H1>

<P>i word</P>

<P>The <B>i</B> command accepts and displays 1 byte (8 bits) from a specified port. 

<DL>
<DT><I>word </I></DT>

<DD>Specifies the 16-bit port address. 
</DD>
</DL>

<P>The following example displays the byte at port address 2F8h: </P>

<P class=indent1>i2F8</P>

<H1>id (Input) </H1>

<P>id word</P>

<P>The <B>id</B> command accepts and displays 1 doubleword (32 bits) from a specified port. 

<DL>
<DT><I>word </I></DT>

<DD>Specifies the 16-bit port address. 
</DD>
</DL>

<P>The following example displays the doubleword at port address 2F8h: </P>

<P class=indent1>i2F8</P>

<H1>iw (Input) </H1>

<P>iw word</P>

<P>The <B>iw</B> command accepts and displays 1 word (16 bits) from a specified port. 

<DL>
<DT><I>word </I></DT>

<DD>Specifies the 16-bit port address. 
</DD>
</DL>

<P>The following example displays the word at port address 2F8h: </P>

<P class=indent1>i2F8</P>

<H1>j (Conditional) </H1>

<P>j expr [cmds-if-true][;cmds-if-false]</P>

<P>The <B>j</B> command executes selected commands based on whether the specified expression is TRUE or FALSE. The <B>j</B> command is useful in breakpoint commands to conditionally break execution when an expression becomes TRUE. 

<DL>
<DT><I>expr </I></DT>

<DD>Evaluates to a Boolean TRUE or FALSE. </DD>

<DT><I>cmds-if-true </I></DT>

<DD>Specifies a list of debugger commands to be executed when expr is TRUE. More than one command can be given, but the commands must be separated by semicolons and the complete list must be enclosed in single or double quotation marks. </DD>

<DT><I>cmds-if-false </I></DT>

<DD>Specifies a list of debugger commands to be executed when expr is FALSE. The preceding semicolon is required. More than one command can be given, but the commands must be separated by semicolons and the complete list must be enclosed in single or double quotation marks. 
</DD>
</DL>

<P>The following example causes execution to continue if EAX equals zero when the breakpoint is reached: </P>

<P class=indent1>bp 167:1454 "J EAX == 0 G"</P>

<P>The following example displays the registers and continues execution when the byte pointed to by DS:SI +3 is equal to 40h; otherwise, it displays the descriptor table: </P>

<P class=indent1>bp 167:1462 "J BY (DS:SI+3) == 40 'R;G';DG DS"</P>

<H1>k (Stack Trace) </H1>

<P>k[b|s|v] [addr] [addr]</P>

<P>This command displays the current (EBP-based) stack frame. Each line shows the name of a procedure, its arguments, and the address of the statement that called it. The command displays four 2-byte arguments by default. The <B>ka</B> command changes the number of arguments displayed by this command. 

<DL>
<DT><B>b </B></DT>

<DD>Indicates the stack frame is 32 bits wide. </DD>

<DT><B>s </B></DT>

<DD>Indicates the stack frame is 16 bits wide. </DD>

<DT><B>v </B></DT>

<DD>Displays the verbose version of stack information — that is, information about stack location and frame pointer values for each frame. </DD>

<DT><I>addr </I></DT>

<DD>Specifies an optional stack-frame address (SS:EBP) or an optional code address (CS:EIP). 
</DD>
</DL>

<P>Using the <B>k</B> command at the beginning of a function (before the function prolog has been executed) gives incorrect results. The command uses the BP register to compute the current backtrace, and this register is not correctly set for a function until its prolog has been executed. </P>

<H1>ka (Stack Trace Arguments) </H1>

<P>ka count</P>

<P>The <B>ka</B> command sets the number of arguments displayed for all subsequent stack trace commands. The initial default value is 4. 

<DL>
<DT><I>count </I></DT>

<DD>Specifies the number of arguments to be displayed. The count parameter must be in the range 0 through 1Fh. 
</DD>
</DL>

<H1>kt (Stack Trace for Task) </H1>

<P>k[b|s|v]t [addr]</P>

<P>This command displays the stack frame of the current task or the task specified by the addr parameter. Each line shows the name of a procedure, its arguments, and the address of the statement that called it. The command displays four 2-byte arguments by default. The <B>ka</B> command changes the number of arguments displayed by this command. 

<DL>
<DT><B>b </B></DT>

<DD>Indicates the stack frame is 32 bits wide. </DD>

<DT><B>s </B></DT>

<DD>Indicates the stack frame is 16 bits wide. </DD>

<DT><B>v </B></DT>

<DD>Displays the verbose version of stack information — that is, information about stack location and frame pointer values for each frame. </DD>

<DT><I>addr </I></DT>

<DD>Specifies the segment address of the process descriptor block (PDB) for the task to be traced. To obtain the addr value, use the .<B>dq</B> (Dump Task Queue) command. If addr is not supplied, the <B>kt</B> command displays the stack frame of the current task. 
</DD>
</DL>

<H1>la (List Absolute Symbols) </H1>

<P>la</P>

<P>The <B>la</B> command lists the absolute symbols in the active map. </P>

<H1>lg (List Groups) </H1>

<P>lg</P>

<P>The <B>lg</B> command lists the address and the name of each group in the active map. </P>

<H1>lm (List Maps) </H1>

<P>lm</P>

<P>The <B>lm</B> command lists the symbol files currently loaded and indicates which one is active. The last symbol file loaded is made active by default. Use the <B>w</B> (Change Map) command to change the active file. </P>

<H1>ln (List Nearest Symbol) </H1>

<P>ln [addr]</P>

<P>The <B>ln</B> command lists the symbol nearest the specified address. The command lists the nearest symbol before and after the specified addr parameter. This command also shows line-number information if it is available in the symbol file. 

<DL>
<DT><I>addr </I></DT>

<DD>Specifies any valid instruction address. The default value is the current disassembly address. 
</DD>
</DL>

<P>The <B>ln</B> command without the addr parameter displays the nearest symbols before and after the current disassembly address. </P>

<P>Example: ln dw(esp) Lists the nearest symbol with respect to the caller (pushed address on stack)</P>

<H1>ls (List Symbols) </H1>

<P>ls group-name | name-chars | *</P>

<P>The <B>ls</B> command lists the symbols in the specified group or lists names that match the search specification in all groups. The search specification uses DOS-style semantics. The only valid wildcard is a single asterisk (*) as the last character on the command line; all other characters are ignored. 

<DL>
<DT><I>group-name </I></DT>

<DD>Names the group that contains the symbols you want to list, for example ESDI_506. </DD>

<DT><I>name-chars </I></DT>

<DD>Specifies the beginning characters of the symbols you want to list. 
</DD>
</DL>

<H1>lse (List Symbols by Regular Expression) </H1>

<P>lse regular-expression</P>

<P>The <B>lse</B> command lists the symbols specified by the given regular expression. The search specification uses UNIX-style semantics.

<DL>
<DT><I>regular-expression </I></DT>

<DD>Can be a regular expression as described in Command Syntax. 
</DD>
</DL>

<H1>m (Move) </H1>

<P>m range addr</P>

<P>The <B>m</B> command moves a block of memory from one memory location to another. If part of the destination block overlaps some of the source block, the move is always performed without loss of data. Addresses that could be overwritten are moved first. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory to be moved. </DD>

<DT><I>addr </I></DT>

<DD>Specifies the starting address at which the memory is to be relocated. 
</DD>
</DL>

<P>For moves from higher to lower addresses, the sequence of events is first to move the data at the block's lowest address and then to work toward the highest. For moves from lower to higher addresses, the sequence is first to move the data at the block's highest address and then to work toward the lowest. </P>

<P>The following example first moves the data at address CS:110 to CS:510 and then moves the data at CS:10F to CS:50F, and so on, until the data at CS:100 is moved to CS:500: </P>

<P class=indent1>mCS:100 110 CS:500</P>

<H1>o (Output) </H1>

<P>o word byte</P>

<P>The <B>o</B> command writes a byte to a 16-bit port address. 

<DL>
<DT><I>word </I></DT>

<DD>Specifies the 16-bit port address to be written to. </DD>

<DT><I>byte </I></DT>

<DD>Specifies the 8-bit value to be written to the port. 
</DD>
</DL>

<P>The following example writes the byte value 4Fh to output port 2F8h: </P>

<P class=indent1>o 2F8 4F</P>

<H1>od (Output) </H1>

<P>o word dword</P>

<P>The <B>o</B> command writes a dword to a 16-bit port address. 

<DL>
<DT><I>word </I></DT>

<DD>Specifies the 16-bit port address to be written to. </DD>

<DT><I>dword </I></DT>

<DD>Specifies the 32-bit value to be written to the port. 
</DD>
</DL>

<P>The following example writes the byte value 8000004Fh to output port 2F8h: </P>

<P class=indent1>o 2F8 8000004F</P>

<H1>ow(Output) </H1>

<P>o word word</P>

<P>The <B>o</B> command writes a word to a 16-bit port address. 

<DL>
<DT><I>word </I></DT>

<DD>Specifies the 16-bit port address to be written to. </DD>

<DT><I>word </I></DT>

<DD>Specifies the 16-bit value to be written to the port. 
</DD>
</DL>

<P>The following example writes the word value 804Fh to output port 2F8h: </P>

<P class=indent1>o 2F8 804F</P>

<H1>p (Program Trace) </H1>

<P>p[n|t|z] [=addr][count]</P>

<P>The <B>p</B> command executes the instruction at a specified address and displays the current values of all the registers and flags (whatever the <B>zd</B> command has been set to). It then executes the default command string, if any. The <B>p</B> command is identical to the <B>t</B> (Trace Instructions) command, except that it automatically executes and returns from any calls or software interrupts it encounters. The <B>t</B> command always stops after executing into the call or interrupt, leaving execution control inside the called routine. 

<DL>
<DT><B>n </B></DT>

<DD>Suppresses the register display so just the assembly line is displayed. The suppression results only if the default command, <B>zd</B>, is set to a normal setting, r. </DD>

<DT><B>t </B>or<B> z </B></DT>

<DD>Allows trapped exceptions to resume at the original trap handler address without having to unhook the exception. </DD>

<DT><I>addr </I></DT>

<DD>Specifies the starting address at which to begin execution. If you omit the optional addr parameter, execution begins at the instruction pointed to by the CS and IP registers. Use the equal sign (=) only if you specify addr. </DD>

<DT><I>count </I></DT>

<DD>Specifies the number of instructions to execute before stopping and executing the default command string. The command executes the default command string for each instruction before executing the next. 
</DD>
</DL>

<P>The following example executes the instruction pointed to by the current CS and IP register values before it executes the default command string: </P>

<P class=indent1>p</P>

<P>The following example executes the instruction at address CS:120 before it executes the default command string: </P>

<P class=indent1>p=120</P>

<P>Program tracing through popf or popfd usually does not work.</P>

<H1>r (Register) </H1>

<P>r[t][reg[=value]]</P>

<P>The <B>r</B> command displays the contents of one or more central processing unit (CPU) registers and allows the contents to be changed to new values. If you specify the reg parameter with the <B>r</B> command, the command displays the value of that register in hexadecimal format and prompts for a new value. If you specify a reg and a value, the command sets the register to the given value. 

<DL>
<DT><B>t </B></DT>

<DD>Displays registers in terse format. </DD>

<DT><I>reg </I></DT>

<DD>Specifies the register to be displayed. If you specify <B>f</B> or <B>msw</B> for reg, the debugger displays the flags in a row at the beginning of a new line and prompts for one or more flag values. If you omit reg, the debugger displays the contents of all registers and flags along with the next executable instruction. </DD>

<DT><I>value </I></DT>

<DD>Specifies the new value for the register. Can be a number or a combination of these flag values: 

<TABLE>

<TR VALIGN="top">
<TH align=left width=50%>Flag</TH>
<TH align=left width=50%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=50%>OV </TD>
<TD width=50%>Overflow set </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>NV </TD>
<TD width=50%>Overflow clear </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>DN </TD>
<TD width=50%>Direction decrement </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>UP </TD>
<TD width=50%>Direction increment </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>EI </TD>
<TD width=50%>Interrupt enabled </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>DI </TD>
<TD width=50%>Interrupt disabled </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>NG </TD>
<TD width=50%>Sign negative </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>PL </TD>
<TD width=50%>Sign positive </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>ZR </TD>
<TD width=50%>Zero set </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>NZ </TD>
<TD width=50%>Zero clear </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>AC </TD>
<TD width=50%>Auxiliary carry set </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>NA </TD>
<TD width=50%>Auxiliary carry clear </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>PE </TD>
<TD width=50%>Parity even </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>PO </TD>
<TD width=50%>Parity odd </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>CY </TD>
<TD width=50%>Carry set </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>NC </TD>
<TD width=50%>Carry clear </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>NT </TD>
<TD width=50%>Nested task switch (on and off) </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>TS </TD>
<TD width=50%>Sets the task switch bit. (MSW only)</TD>
</TR>

<TR VALIGN="top">
<TD width=50%>EM </TD>
<TD width=50%>Sets the emulation processor extension bit. (MSW only) </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>MP </TD>
<TD width=50%>Sets the monitor processor extension bit. (MSW only) </TD>
</TR>

<TR VALIGN="top">
<TD width=50%>PM </TD>
<TD width=50%>Sets the protected-mode bit. (MSW only) </TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<P>Flag values can be in any order. You do not have to leave spaces between these values. </P>

<P>If you type more than one value for a flag or enter an invalid flag name, the flags up to the error in the list are changed and those flags at and after the error are not changed. In addition, the debugger display the message: "Bad Flag." </P>

<P>Setting the protected-mode bit from within the debugger does not set the target system to run in protected mode. The debugger simulates the setting. To configure the target system to run in protected mode, you would have to set the PM bit in the MSW register and reset the target system to restart in protected mode. </P>

<P>See also the <B>.r</B> command.</P>

<H1>s (Search) </H1>

<P>s range list | "string"</P>

<P>The <B>s</B> command searches an address range for a specified list of bytes or an ASCII character string. You can include one or more bytes in list, but multiple bytes must be separated by a space or comma. When you search for more than one byte, the command returns the address of only the first byte in the string. When list contains only one byte, the debugger displays the addresses of all occurrences of the byte in range. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory to be searched. </DD>

<DT><I>list </I></DT>

<DD>Specifies one or more byte values to search for. </DD>

<DT><I>string </I></DT>

<DD>Specifies an ASCII character string to be searched for. The string must be enclosed in quotation marks. 
</DD>
</DL>

<P>The following example searches for byte 41h in the address range CS:100 to CS:110: </P>

<P class=indent1>sCS:100 110 41</P>

<P class=indent1>04BA:0104</P>

<P class=indent1>04BA:010D</P>

<H1>t (Trace) </H1>

<P>t[a|c|n|s|x|z][=start_addr][count][addr]</P>

<P>The <B>t</B> command executes one or more instructions along with the default command string and then displays the decoded instruction. If you include the start_addr parameter, tracing starts at the specified address. Otherwise, the command steps through the next machine instruction and then executes the default command string. The <B>t</B> command uses the hardware trace mode of the Intel microprocessor. Consequently, you can also trace instructions stored in read-only memory (ROM). 

<DL>
<DT><B>a </B></DT>

<DD>Indicates that an ending address is specified for the trace. Instructions are traced until the address in addr is reached. </DD>

<DT><B>c </B></DT>

<DD>Suppresses all output and counts instructions traced. An ending address is required for this command. Instructions are traced until the address in addr is reached. </DD>

<DT><B>n </B></DT>

<DD>Suppresses the register display so just the assembly line is displayed. This works only if the default command, <B>zd</B>, is set to <B>r</B> (the normal setting). </DD>

<DT><B>s </B></DT>

<DD>Suppresses output; the instruction and count are displayed for each <B>call</B> and the return from that call. </DD>

<DT><B>x </B></DT>

<DD>Forces the debugger to trace regions of code known to be untraceable (_PGSwitchContext, for example). </DD>

<DT><B>z </B></DT>

<DD>Allows original trap handler address to be traced into without having to unhook the exception. Use this option instead of <B>vcp</B> <B>d;</B> <B>t</B>; <B>vsp</B> <B>d</B>. </DD>

<DT><I>start_addr </I></DT>

<DD>Specifies the instruction address at which to start tracing. The equal sign (=) is required. </DD>

<DT><I>count </I></DT>

<DD>Specifies the number of instructions to execute and trace. </DD>

<DT><I>addr </I></DT>

<DD>Specifies the instruction address at which to stop tracing. 
</DD>
</DL>

<P>The following command causes the debugger to execute 16 (10h) instructions beginning at 011A in the current selector: </P>

<P class=indent1>t=011A 10</P>

<P>The debugger executes and displays the results of the default command string for each instruction. The display is scrolled until the last instruction is executed. Press the CTRL+S key combination to stop the scrolling and CTRL+Q to resume. </P>

<P>This command does not trace into INTs (but will trace out), and tracing through popf or popfd usually does not work.</P>

<H1>u (Disassemble) </H1>

<P>u [range]</P>

<P>The <B>u</B> command disassembles bytes and displays the source statements, with addresses and byte values that correspond to them. The display of disassembled code looks similar to a code listing for an assembled file. If you type the <B>u</B> command by itself, 20h bytes are disassembled at the first address after the one displayed by the previous <B>u</B> command. 

<DL>
<DT><I>range </I></DT>

<DD>Specifies the block of memory in which instructions are to be disassembled. If no range is given, the command disassembles the next 20h bytes. 
</DD>
</DL>

<H1>v (Version Number) </H1>

<P>v</P>

<P>The <B>v</B> command displays the current debugger version number and date. </P>

<H1>vc (Vector Clear) </H1>

<P>vc[n | p | r | v] number[,number [,...]]</P>

<P>The <B>vc</B> command clears the specified interrupt vector and reinstalls the previous interrupt vector. 

<DL>
<DT><B>n </B></DT>

<DD>Removes the beep from traps that beep when encountered; does not clear the traps. </DD>

<DT><B>p </B></DT>

<DD>Clears protected-mode vectors only. </DD>

<DT><B>r </B></DT>

<DD>Clears real-mode vectors only. </DD>

<DT><B>v </B></DT>

<DD>Clears virtual 8086 (V86) mode vectors only. </DD>

<DT><I>number </I></DT>

<DD>Specifies the interrupt vector to clear. 
</DD>
</DL>

<P>For protected-mode games, type <B>vcp 1 3</B> before running the app, and<B> vtp 1 3</B> after exiting the app, to avoid “unexpected trace interrupt” errors. For DOS apps, use <B>vcv 1 3</B> and <B>vsv 1 3</B>. To recover from the error message, first remove the vector, then type <B>gt</B>.</P>

<H1>vl (Vector List) </H1>

<P>vl[n | p | r | v]</P>

<P>Lists the interrupt vectors that the debugger intercepts. Vectors that have been set with the <B>vt</B> command (as opposed to <B>vs</B>) are listed with an asterisk (*) following the vector number. 

<DL>
<DT><B>n </B></DT>

<DD>Lists the traps that beep when encountered. </DD>

<DT><B>p </B></DT>

<DD>Lists the protected-mode vectors only. </DD>

<DT><B>r </B></DT>

<DD>Lists the real-mode vectors only. </DD>

<DT><B>v </B></DT>

<DD>Lists the virtual 8086 (V86) mode vectors only. 
</DD>
</DL>

<H1>vo (Vector List New) </H1>

<P>vo[n | p | r | v]</P>

<P>The <B>vo</B> command lists interrupt vectors in the display format based on the newvec option. For details, see the <B>y</B> command. 

<DL>
<DT><B>n </B></DT>

<DD>Lists the traps that beep when encountered. </DD>

<DT><B>p </B></DT>

<DD>Lists the protected-mode vectors only. </DD>

<DT><B>r </B></DT>

<DD>Lists the real-mode vectors only. </DD>

<DT><B>v </B></DT>

<DD>Lists the virtual 8086 (V86) mode vectors only. 
</DD>
</DL>

<H1>vs (Vector Trap Non-Supervisor) </H1>

<P>vs[n | p | r | v] number[,number[,...]]</P>

<P>The <B>vs</B> command adds a new interrupt vector to the list of intercepted vectors. Vectors set by this command do not intercept interrupts that occur at ring 0. 

<DL>
<DT><B>n </B></DT>

<DD>Beep when trap encountered. </DD>

<DT><B>p </B></DT>

<DD>Set trap for protected-mode vectors only. </DD>

<DT><B>r </B></DT>

<DD>Set trap for real-mode vectors only. </DD>

<DT><B>v </B></DT>

<DD>Set trap for virtual 8086 (V86) mode vectors only. </DD>

<DT><I>number </I></DT>

<DD>Specifies the interrupt vector to intercept. 
</DD>
</DL>

<H1>vt (Vector Trap) </H1>

<P>vt[n | p | r | v] number[,number[,...]]</P>

<P>The <B>vt</B> command adds a new interrupt vector to the list of intercepted vectors. 

<DL>
<DT><B>n </B></DT>

<DD>Beep when trap encountered. </DD>

<DT><B>p </B></DT>

<DD>Set trap for protected-mode vectors only. </DD>

<DT><B>r </B></DT>

<DD>Set trap for real-mode vectors only. </DD>

<DT><B>v </B></DT>

<DD>Set trap for virtual 8086 (V86) mode vectors only. </DD>

<DT><I>number </I></DT>

<DD>Specifies the interrupt vector to intercept. 
</DD>
</DL>

<H1>w (Change Map) </H1>

<P>w [map-name]</P>

<P>The <B>w</B> command changes the active map file. 

<DL>
<DT><I>map-name </I></DT>

<DD>Specifies the name of the map file you want to make active. Use the <B>lm</B> (List Map) command to display a list of available map files. 
</DD>
</DL>

<P>If map-name is not specified, the loaded maps are displayed and the user is prompted to select a map by pressing its corresponding number. </P>

<H1>wa (Activate Map) </H1>

<P>wa map-name</P>

<P>The <B>wa</B> command adds the specified map to the list of active maps. 

<DL>
<DT><I>map-name </I></DT>

<DD>Specifies the map to add to the list of active maps. 
</DD>
</DL>

<H1>wr (Deactivate Map) </H1>

<P>wr map-name</P>

<P>The <B>wr</B> command removes the specified map from the list of active maps. 

<DL>
<DT><I>map-name </I></DT>

<DD>Specifies the map to remove from the list of active maps. 
</DD>
</DL>

<H1>x (Dump Debug Report) </H1>

<P>x</P>

<P>Dumps a listing of the current execution environment. </P>

<H1>y (Debugger Options) </H1>

<P>y[? | option]</P>

<P>The <B>y</B> command changes the debugger configuration. The following list describes the available configuration options. All settings are toggles. 

<DL>
<DT><B>? </B></DT>

<DD>Displays a list of supported options. </DD>

<DT><I>option </I></DT>

<DD>Following are the available configuration options: 

<TABLE>

<TR VALIGN="top">
<TD width=50%><B>/a </B></TD>
<TD width=50%>Controls automatic symbol loading. If this option is set, Windows will not load symbols automatically. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>/n </B></TD>
<TD width=50%>Sets the following options, listed in more detail further below:<BR>
<B>codebytes  dislwr  int3line  newprompt  newreg  newvec  symaddrs</B></TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B> /v </B></TD>
<TD width=50%>Controls segment load notification messages. If this option is set, all segment load notifications will be displayed. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B> 386env </B></TD>
<TD width=50%>Controls the size of addresses, registers, and so on when displayed. When this option is on, addresses, registers, and so on are shown in 32-bit format; otherwise, they are shown in 16-bit format. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B> codebytes </B></TD>
<TD width=50%>Causes code bytes to be displayed along with disassembled instructions. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B> crdelay =</B></TD>
<TD width=50%>Implements a delay between lines emitted to the debug terminal. Specify the number of ASCII nulls between lines (0-FFFFH).</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B> disaddr </B></TD>
<TD width=50%>Causes addresses to be displayed with disassembled instructions. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B> disline </B></TD>
<TD width=50%>Causes filenames and line numbers to be displayed with disassembled instructions. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>dislwr </B></TD>
<TD width=50%>Causes register and instruction names to be displayed in lowercase letters. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>int3line </B></TD>
<TD width=50%>Causes the filename and line number to be displayed with int 3 instructions. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>newprompt </B></TD>
<TD width=50%>Causes a double prompt when paging is enabled and a nesting level if the debugger is reentered. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>newreg </B></TD>
<TD width=50%>Changes the format of the register display to the newer format accommodating 32 bit registers.</TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>newvec </B></TD>
<TD width=50%>Controls the display format for the intercepted interrupt vectors. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>regterse </B></TD>
<TD width=50%>Controls the number of registers displayed by the r (Register) command. When regterse is on, only the first three lines are displayed (instead of the normal six lines plus disassembly line). </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>scrncols </B></TD>
<TD width=50%>Sets the number of screen columns in the debug display. The default is 79 columns. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>scrnlines </B></TD>
<TD width=50%>Sets the number of screen lines in the debug display. The default is 24 lines. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>skipint3s </B></TD>
<TD width=50%>Causes the debugger to ignore inline int 3 instructions. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>symaddrs </B></TD>
<TD width=50%>Causes symbol values to be displayed with the symbols. </TD>
</TR>

<TR VALIGN="top">
<TD width=50%><B>teftibase </B></TD>
<TD width=50%>Sets the base port address for the timing card. See MSDN Library CD:  Q85897, “DEBUGGER.EXE-Compatible Timing Card Available”</TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<H1>z (Zap) </H1>

<P>z</P>

<P>Replaces the instruction bytes of the current <B>int 3</B> instruction or the previous <B>int 1</B> instruction with nop instructions. This allows the user to avoid <B>int 1</B> or <B>int 3</B> instructions that were assembled into the executable file by breaking into the debugger more than once. </P>

<P>You can also <B>z)</B>ap debug_out’s; they will be automatically converted to trace_out, so they stop trapping..</P>

<H1>zd (Execute Default) </H1>

<P>zd</P>

<P>The <B>zd</B> command executes the default command string. The default command string is initially set to the <B>r</B> (Register) command by the debugger. The default command string is executed every time a breakpoint is encountered during execution of the application or whenever a <B>p</B> (Program Trace) or <B>t</B> (Trace) command is executed. </P>

<P>Use the <B>zl</B> command to display the default command string and the <B>zs</B> command to change the default command string. </P>

<H1>zl (Display Default) </H1>

<P>zl</P>

<P>The <B>zl</B> command displays the default command string. </P>

<H1>zs (Set Default) </H1>

<P>zs "string"</P>

<P>The <B>zs</B> command makes it possible for you to change the default command string. 

<DL>
<DT><I>string </I></DT>

<DD>Specifies the new default command string. The string must be enclosed in single or double quotation marks. You must separate the debugger commands within the string with semicolons. 
</DD>
</DL>

<P>The following example changes the current default command string to an <B>r</B> (Display Register) command followed by a <B>c</B> (Compare Memory) command: </P>

<P class=indent1>zs "r;c100 L 100 300"</P>

<P>The following example begins execution whenever an <B>int 3</B> instruction is executed in your test application. This example executes a <B>g</B> (Go) command every time an <B>int 3</B> instruction is executed. </P>

<P class=indent1>zs "j (by cs:ip) == cc 'g'"</P>

<P>You can use zs as follows to set up a watchpoint: </P>

<P class=indent1>zs "j (wo 40:1234) == 0eeed;t"</P>

<P>This command traces until the word at 40:1234 is not equal to 0EEED. This does not work if you are tracing through the mode switching code in MS-DOS or other sections of code that cannot be traced. </P>

<P></P>
<DIV CLASS="footer"><A HREF="mailto:ddksurv1@microsoft.com?subject=DDK Topic Feedback&body=Build date: Thursday, January 16, 2003     Topic Title: DEBUGGER.EXE%20Command%20Details"> Send feedback on this topic.</A> / Built on Thursday, January 16, 2003 </DIV>
</BODY>
</HTML>
