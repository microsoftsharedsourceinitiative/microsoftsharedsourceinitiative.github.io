<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>IFSMgr_UnlockFile</TITLE>
<SCRIPT SRC="../scripts/linkcss.js"></SCRIPT><SCRIPT SRC="../scripts/langref.js"></SCRIPT></HEAD>
<BODY TOPMARGIN="0">

<TABLE CLASS="buttonbarshade" CELLSPACING=0><TR><TD>&nbsp;</TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING=0>
<TR ID="hdr"><TD CLASS="runninghead" NOWRAP>Windows&nbsp;98/Me:&nbsp;Windows&nbsp;DDK</TD></TR>
</TABLE>
<H3><A NAME="_pss_4491"></A>IFSMgr_UnlockFile</H3>

<PRE>IFSMgr_UnlockFile(
 void ** ppFSDLockListHead,
 unsigned long LockOffset,
 unsigned long LockLength,
 unsigned long LockOwner,
 void * pOpenFileInstance,
 unsigned long fLockSemantics
 )
 </PRE>

<P>This service unlocks a previously locked region of an open file. The offset and the length of the region to be unlocked should correspond exactly to a previously locked region. This is true even in the case where there are overlapping locks. The IFS manager just walks the list of locks on the file and sees if it finds a match with one of them. If it does, it frees that lock entry from the list. 

<DL>
<DT><I>ppFSDLockListHead</I> </DT>

<DD>Supplies a pointer to a variable that contains the pointer to the list of locks. </DD>

<DT><I>LockOffset</I> </DT>

<DD>Supplies the starting offset in the file of the region to be locked. </DD>

<DT><I>LockLength</I> </DT>

<DD>Supplies the length of region in the file to be locked. </DD>

<DT><I>LockOwner</I> </DT>

<DD>Supplies the process ID of the process requesting the lock. </DD>

<DT><I>pOpenFileInstance</I> </DT>

<DD>Supplies a pointer to the structure that describes the current open file instance. </DD>

<DT><I>fLockSemantics</I> </DT>

<DD>Supplies flags indicating what kind of locking semantics are operative. 

<TABLE>

<TR VALIGN="top">
<TD width=34%><B>Lock Semantics Flags:</B> </TD>
<TD width=66%>&nbsp;</TD>
</TR>

<TR VALIGN="top">
<TH align=left width=34%>Value </TH>
<TH align=left width=66%>Meaning </TH>
</TR>

<TR VALIGN="top">
<TD width=34%>LOCKF_DOS </TD>
<TD width=66%>Indicates that DOS semantics are to be applied for the lock request. </TD>
</TR>

<TR VALIGN="top">
<TD width=34%>LOCKF_NW </TD>
<TD width=66%>Indicate that NetWare semantics are to be applied for the lock request. </TD>
</TR>

<TR VALIGN="top">
<TD width=34%>LOCKF_RD </TD>
<TD width=66%>Indicates that a read lock should be taken. This value is allowed only with LOCKF_NW. DOS semantics do not have the concept of a read lock. </TD>
</TR>

<TR VALIGN="top">
<TD width=34%>LOCKF_WR </TD>
<TD width=66%>Indicates that a write lock should be taken. </TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<UL>
	<LI>Returns zero if success, error code if failure. </LI>
</UL>

<TABLE>

<TR VALIGN="top">
<TD width=34%><I>ppFSDLockListHead</I> </TD>
<TD width=66%>The lock list head stored in this variable might have been updated. </TD>
</TR>
</TABLE><BR>
<DIV CLASS="footer"><A HREF="mailto:ddksurv1@microsoft.com?subject=DDK Topic Feedback&body=Build date: Thursday, January 16, 2003     Topic Title: IFSMgr_UnlockFile"> Send feedback on this topic.</A> / Built on Thursday, January 16, 2003 </DIV>
</BODY>
</HTML>
