<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Win32 Multilingual IME Application Programming Interface</TITLE>
<SCRIPT SRC="../scripts/linkcss.js"></SCRIPT><SCRIPT SRC="../scripts/langref.js"></SCRIPT><META NAME="MS-HKWD" CONTENT="Win32 Multilingual IME Application Programming Interface">
</HEAD>
<BODY TOPMARGIN="0">

<TABLE CLASS="buttonbarshade" CELLSPACING=0><TR><TD>&nbsp;</TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING=0>
<TR ID="hdr"><TD CLASS="runninghead" NOWRAP>Appendix:&nbsp;Windows&nbsp;DDK</TD></TR>
</TABLE>
<H1><A NAME="ddk_supp_win32_multilingual_ime_application_programming_interface"></A>Win32 Multilingual IME Application Programming Interface</H1>

<P>This documentation contains the application programming interface reference for Input Method Editor (IME)development. The following functions are intended to be used by the IME.</P>

<H2>IMM UI Functions</H2>

<P>Following are the Input Method Manager (IMM) functions that can be accessed from the UI window. They are also used by applications to change IME status.</P>

<P class=indent1><B>ImmGetCompositionWindow</B></P>

<P class=indent1><B>ImmSetCompositionWindow</B></P>

<P class=indent1><B>ImmGetCandidateWindow</B></P>

<P class=indent1><B>ImmSetCandidateWindow</B></P>

<P class=indent1><B>ImmGetCompositionString</B></P>

<P class=indent1><B>ImmSetCompositionString</B></P>

<P class=indent1><B>ImmGetCompositionFont</B></P>

<P class=indent1><B>ImmSetCompositionFont</B></P>

<P class=indent1><B>ImmGetNumCandidateList</B></P>

<P class=indent1><B>ImmGetCandidateList</B></P>

<P class=indent1><B>ImmGetGuideLine</B></P>

<P class=indent1><B>ImmGetConversionStatus</B></P>

<P class=indent1><B>ImmGetConversionList</B></P>

<P class=indent1><B>ImmGetOpenStatus</B></P>

<P class=indent1><B>ImmSetConversionStatus</B></P>

<P class=indent1><B>ImmSetOpenStatus</B></P>

<P class=indent1><B>ImmNotifyIME</B></P>

<P class=indent1><B>ImmCreateSoftKeyboard</B></P>

<P class=indent1><B>ImmDestroySoftkeyboard</B></P>

<P class=indent1><B>ImmShowSoftKeyboard</B></P>

<P>Please refer to the Input Method Editor (IME) functions in the Platform SDK for information about these functions.</P>

<H2>IMM Support Functions</H2>

<P>The following topics contain IMM functions that support and are used by the IME.</P>

<H1>ImmGenerateMessage</H1>

<P>The IME uses the <B>ImmGenerateMessage</B> function to send messages to the <B>hWnd</B> of <I>hIMC</I>. The messages to be sent are stored in hMsgBuf of <I>hIMC</I>.</P>

<PRE class=syntax><B>BOOL WINAPI
</B>  <B>ImmGenerateMessage(
</B>    <B>HIMC  </B><I>hIMC
 </I>   <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle containing <I>hMsgBuf</I>.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H4>Comments</H4>

<P>This is a general purpose function. Typically, an IME uses this function when it is notified about the context update through <B>ImmNotifyIME</B> from IMM. In this case, even if IME needs to provide messages to an application, there is no keystroke in the application’s message queue.</P>

<P>An IME User Interface should not use this function when it only wants to update the UI appearance. The IME User Interface should have been updated when the IME is informed about the updated Input Context. It is recommended that you use this function from the IME only when the IME changes the Input Context without any keystroke given and needs to inform an application of the change.</P>

<H1>ImmRequestMessage</H1>

<P>The <B>ImmRequestMessage</B> function is used to send a <B>WM_IME_REQUEST</B> message to the application. </P>

<PRE class=syntax><B>LRESULT WINAPI
</B>  <B>ImmRequestMessage(
</B>    <B>HIMC  </B><I>hIMC<B>,
</B></I>    <B>WPARAM  </B><I>wParam<B>,
</B></I>    <B>LPARAM  </B><I>lParam<B>
 </B></I>   <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Target input context handle.</DD>

<DT><I>wParam</I></DT>

<DD><I>wParam</I> for the <B>WM_IME_REQUEST</B> message.</DD>

<DT><I>lParam</I></DT>

<DD><I>lParam</I> for the <B>WM_IME_REQUEST</B> message.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value is the return value of the <B>WM_IME_REQUEST</B> message.</P>

<H4>Comments</H4>

<P>This function is new for Windows® 98 and Window 2000, and is used by the IME to send a <B>WM_IME_REQUEST</B> message to the application. The IME may want to obtain some guidelines from the application in defining the position of the candidate or composition window. But in an IME fully aware (true in-line) application, the application usually does not set the composition window position. When the IME makes a request to the application, it receives the <B>WM_IME_REQUEST</B> message. The IME should make a request to the application by calling the <B>ImmRequestMessage </B>function and not by calling <B>SendMessage</B></P>

<P>The following is a list of submessages that the IME can send to applications through the <B>ImmRequestMessage </B>function:</P>

<P class=indent1>IMR_COMPOSITIONWINOW</P>

<P class=indent1>IMR_CANDIDATEWINDOW</P>

<P class=indent1>IMR_COMPOSITIONFONT</P>

<P class=indent1>IMR_RECONVERTSTRING</P>

<P class=indent1>IMR_CONFIRMRECONVERTSTRING</P>

<P class=indent1>IMR_QUERYCHARPOSITION</P>

<P class=indent1>IMR_DOCUMENTFEED</P>

<P>Please refer to the Input Method Editor (IME) functions in the Platform SDK for information about these messages.</P>

<H2>HIMC and HIMCC Management Functions</H2>

<P>The following topics contain the HIMC and HIMCC management functions.</P>

<H1>ImmLockIMC</H1>

<P>The <B>ImmLockIMC</B> function increases the lock count for the IMC. When the IME needs to see the <B>INPUTCONTEXT</B> structure, it calls this function to get the pointer of the <B>INPUTCONTEXT</B> structure.</P>

<PRE class=syntax><B>LPINPUTCONTEXT WINAPI
</B>  <B>ImmLockIMC(
</B>    <B>HIMC  </B><I>hIMC<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, it returns a pointer to the <B>INPUTCONTEXT</B> structure. Otherwise, it returns NULL.</P>

<H1>ImmUnlockIMC</H1>

<P>The <B>ImmUnlockIMC</B> function decrements the lock count for the IMC.</P>

<PRE class=syntax><B>BOOL WINAPI
</B>  <B>ImmUnlockIMC(
</B>    <B>HIMC  </B><I>hIMC<B>
 </B></I>   <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the lock count of the IMC is decremeted to zero, the return value is FALSE. Otherwise, the return value is TRUE.</P>

<H1>ImmGetIMCLockCount</H1>

<P>The <B>ImmGetIMCLockCount</B> is used to get the lock count of the IMC.</P>

<PRE class=syntax><B>HIMCC WINAPI
</B>  <B>ImmGetIMCLockCount(
</B>    <B>HIMC  </B><I>hIMC
 </I>   <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is the lock count of the IMC. Otherwise, the return value is NULL.</P>

<H1>ImmCreateIMCC</H1>

<P>The <B>ImmCreateIMCC</B> function creates a new component as a member of the IMC.</P>

<PRE class=syntax><B>HIMCC WINAPI
</B>  <B>ImmCreateIMCC(
</B>    <B>DWORD  </B><I>dwSize<B>
 </B></I>   <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>dwSize</I></DT>

<DD>Size of the new IMC component.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is the IMC component handle (HIMCC). Otherwise, the return value is NULL.</P>

<H4>Comments</H4>

<P>The IMC component created by this function is initialized as zero.</P>

<H1>ImmDestroyIMCC</H1>

<P>The <B>ImmDestroyIMCC </B>function is used by the IME to destroy the IMC component that was created as a member of the IMC.</P>

<PRE class=syntax><B>HIMCC WINAPI
</B>  <B>ImmDestroyIMCC(
</B>    <B>HIMCC  </B><I>hIMCC<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMCC</I></DT>

<DD>Handle of the IMC component.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is NULL. Otherwise, the return value is equal to the HIMCC.</P>

<H1>ImmLockIMCC</H1>

<P>The <B>ImmLockIMCC</B> function is used by the IME to get the pointer for the IMC component that was created as a member of the IMC. The <B>ImmLockIMC</B> function increases the lock count for the IMCC.</P>

<PRE class=syntax><B>LPVOID WINAPI
</B>  <B>ImmLockIMCC(
</B>    <B>HIMCC  </B><I>hIMCC
</I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMCC</I></DT>

<DD>Handle of the IMC component.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is the pointer for the IMC component. Otherwise, the return value is NULL.</P>

<H1>ImmUnlockIMCC</H1>

<P>The <B>ImmUnlockIMC</B> function decrements the lock count for the IMCC.</P>

<PRE class=syntax><B>BOOL WINAPI
</B>  <B>ImmUnlockIMCC(
</B>    <B>HIMCC  </B><I>hIMCC<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMCC</I></DT>

<DD>Handle of the IMC component.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the lock count of the IMCC is decremeted to zero, the return value is FALSE. Otherwise, the return value is TRUE.</P>

<H1>ImmReSizeIMCC</H1>

<P>The <B>ImmReSizeIMCC</B> function changes the size of the component.</P>

<PRE class=syntax><B>HIMCC WINAPI
</B>  <B>ImmReSizeIMCC(
</B>    <B>HIMCC  </B><I>hIMCC</I><B>,
</B>    <B>DWORD  </B><I>dwSize<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMCC</I></DT>

<DD>Handle of the IMC component.</DD>

<DT><I>dwSize</I></DT>

<DD>New size of the IMC component.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is the new HIMCC. Otherwise, the return value is NULL.</P>

<H1>ImmGetIMCCSize</H1>

<P>The <B>ImmGetIMCCLockCount</B> function is used to get the size of the IMCC.</P>

<PRE class=syntax><B>DWORD WINAPI
</B>  <B>ImmGetIMCCSize(
</B>    <B>HIMCC  </B><I>hIMCC<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMCC</I></DT>

<DD>Handle of the IMC component.
</DD>
</DL>

<H4>Return Values</H4>

<P>Size of the IMCC.</P>

<H1>ImmGetIMCCLockCount</H1>

<P>The <B>ImmGetIMCCLockCount</B> function is used to get the lock count of the IMCC.</P>

<PRE class=syntax><B>DWORD WINAPI</B>
  <B>ImmGetIMCCLockCount(
</B>    <B>HIMCC  </B><I>hIMCC<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMCC</I></DT>

<DD>Handle of the IMC component.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is the lock count of the IMCC. Otherwise, the return value is zero.</P>

<H2>IME Hot Keys and Hot Key Functions</H2>

<P>The IME hot key is used for changing the IME input mode and for switching the IME. The IME hot key used to switch directly to an IME is called a <I>direct switching hot key</I>.</P>

<P>The direct switching hot key ranges from IME_HOTKEY_DSWITCH_FIRST to IME_HOTKEY_DSWITCH_LAST. It is registered by an IME or Control Panel when the IME or an end user wants such a hot key. The IME hot key is effective in all IMEs, regardless which IME is active.</P>

<P>There are several predefined hot key functionalities in the IMM. The IMM itself provides the functionality (different handling routines) of those hot key functions. Every hot key funtionality has a different hot key ID in IMM and each ID has its own functionality according to the specific requirements of each country/region. Note that an application cannot add another predefined hot key ID into the system.</P>

<P>Following are the predefined hot key identifiers.</P>

<TABLE>

<TR VALIGN="top">
<TH align=left width=58%>Hot Key ID</TH>
<TH align=left width=42%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=58%>IME_CHOTKEY_IME_NONIME_TOGGLE</TD>
<TD width=42%>Hot key for Simplified Chinese Edition. This hot key toggles between the IME and non-IME.</TD>
</TR>

<TR VALIGN="top">
<TD width=58%>IME_CHOTKEY_SHAPE_TOGGLE</TD>
<TD width=42%>Hot key for Simplified Chinese Edition. This hot key toggles the shape conversion mode of the IME.</TD>
</TR>

<TR VALIGN="top">
<TD width=58%>IME_CHOTKEY_SYMBOL_TOGGLE</TD>
<TD width=42%>Hot key for Simplified Chinese Edition. This hot key toggles the symbol conversion mode of the IME. The symbol mode indicates that the user can input Chinese punctuation and symbols (full shape characters) by mapping it to the punctuation and symbol keystrokes of the keyboard.</TD>
</TR>

<TR VALIGN="top">
<TD width=58%>IME_JHOTKEY_CLOSE_OPEN</TD>
<TD width=42%>Hot key for Japanese Edition. This hot key toggles between closed and opened.</TD>
</TR>

<TR VALIGN="top">
<TD width=58%>IME_THOTKEY_IME_NONIME_TOGGLE</TD>
<TD width=42%>Hot key for (Traditional) Chinese Edition. This hot key toggles between the IME and non-IME.</TD>
</TR>

<TR VALIGN="top">
<TD width=58%>IME_THOTKEY_SHAPE_TOGGLE</TD>
<TD width=42%>Hot key for (Traditional) Chinese Edition. This hot key toggles the shape conversion mode of the IME.</TD>
</TR>

<TR VALIGN="top">
<TD width=58%>IME_THOTKEY_SYMBOL_TOGGLE</TD>
<TD width=42%>Hot key for (Traditional) Chinese Edition. This hot key toggles the symbol conversion mode of the IME.</TD>
</TR>
</TABLE><BR>

<P>The other kind of hot key is the IME <I>private hot key,</I> but there is no functionality for this kind of hot key. It is just a placeholder for a hot key value. An IME can get this value by calling <B>ImmGetHotKey</B>. If an IME supports this functionality for one hot key ID, it will perform the functionality every time it finds this key input.</P>

<P>Following are the currently defined private IME hot key IDs.</P>

<TABLE>

<TR VALIGN="top">
<TH align=left width=63%>Hot Key ID</TH>
<TH align=left width=37%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=63%>IME_ITHOTKEY_RESEND_RESULSTR</TD>
<TD width=37%>Hot key for (Traditional) Chinese Edition. This hot key should trigger the IME to resend the previous result string to the application. If the IME detects that this hot key is pressed, it needs to resend the previous result string to this application.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>IME_ITHOTKEY_PREVIOUS_COMPOSITION</TD>
<TD width=37%>Hot key for (Traditional) Chinese Edition. This hot key should trigger the IME to bring up the previous composition string to the application.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>IME_ITHOTKEY_UISTYLE_TOGGLE</TD>
<TD width=37%>Hot key for (Traditional) Chinese Edition. This hot key should trigger the IME UI to toggle the UI style between caret-related UI and the caret-unrelated UI.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>IME_ITHOTKEY_RECONVERTSTRING</TD>
<TD width=37%>Hot key for (Traditional) Chinese Edition. This hot key should trigger the IME to make a reconversion. This is a new ID for Windows 98 and Windows 2000.</TD>
</TR>
</TABLE><BR>

<H1>ImmGetHotKey</H1>

<P>The <B>ImmGetHotKey</B> function gets the value of the IME hot key.</P>

<PRE class=syntax><B>BOOL WINAPI</B>
  <B>ImmGetHotKey(
</B>    <B>DWORD  </B><I>dwHotKeyID</I><B>,
</B>    <B>LPUINT  </B><I>lpuModifiers</I><B>,
</B>    <B>LPUINT  </B><I>lpuVKey</I><B>,
</B>    <B>LPHKL  </B><I>lphKL</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>dwHotKeyID</I></DT>

<DD>Hot key identifier.</DD>

<DT><I>lpuModifiers</I></DT>

<DD>Combination keys with the hot key. It includes ALT (MOD_ALT), CTRL (MOD_CONTROL), SHIFT (MOD_SHIFT), left-hand side (MOD_LEFT), and right-hand side (MOD_RIGHT).

<P>The key up flag (MOD_ON_KEYUP) indicates that the hot key is effective when the key is up. The modifier ignore flag (MOD_IGNORE_ALL_MODIFIER) indicates that the combination of modifiers is ignored in hot key matching.
</DD>

<DT><I>lpuVKey</I></DT>

<DD>Virtual key code of this hot key.</DD>

<DT><I>lphKL</I></DT>

<DD>HKL of the IME. If the return value of this parameter is not NULL, this hot key can switch to the IME with this HKL.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H4>Comments</H4>

<P>This function is called by the Control Panel.</P>

<H1>ImmSetHotKey</H1>

<P>The <B>ImmSetHotKey</B> function sets the value of the IME hot key.</P>

<PRE class=syntax><B>OOL WINAPI</B>
  <B>ImmSetHotKey(
</B>    <B>DWORD  </B><I>dwHotKeyID</I><B>,
</B>    <B>UINT  </B><I>uModifiers</I><B>,
</B>    <B>UINT  </B><I>uVKey</I><B>,
</B>    <B>hKL  </B><I>hKL</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>dwHotKeyID</I></DT>

<DD>Hot key identifier.</DD>

<DT><I>uModifiers</I></DT>

<DD>Combination keys with the hot key. It includes ALT (MOD_ALT), CTRL (MOD_CONTROL), SHIFT (MOD_SHIFT), left-hand side (MOD_LEFT), and right-hand side (MOD_RIGHT).

<P>The key up flag (MOD_ON_KEYUP) indicates that the hot key is effective when the key is up. The modifier ignore flag (MOD_IGNORE_ALL_MODIFIER) indicates that the combination of modifiers is ignored in hot key matching.
</DD>

<DT><I>uVKey</I></DT>

<DD>Virtual key code of this hot key.</DD>

<DT><I>hKL</I></DT>

<DD>HKL of the IME. If this parameter is specified, this hot key can switch to the IME with this HKL.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H4>Comments</H4>

<P>This function is called by the Control Panel. For a key that does not indicate a specific keyboard hand side, the <I>uModifiers</I> should specify both sides (MOD_LEFT|MODE_RIGHT).</P>

<H2>IMM Soft Keyboard Functions</H2>

<P>The following topics contain the IMM functions that are used by the IME to manipulate the soft keyboard.</P>

<H1>ImmCreateSoftKeyboard</H1>

<P>The <B>ImmCreateSoftKeyboard</B> function creates one type of soft keyboard window.</P>

<PRE class=syntax><B>HWND WINAPI</B>
  <B>ImmCreateSoftKeyboard(
</B>    <B>UINT  </B><I>uType<B>,
</B></I>    <B>UINT  </B><I>hOwner<B>,
</B></I>    <B>int  </B><I>x<B>,
</B></I>    <B>int  </B><I>y<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>uType</I></DT>

<DD>Specifies the type of the soft keyboard.

<TABLE>

<TR VALIGN="top">
<TH align=left width=48%>Utype</TH>
<TH align=left width=52%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=48%>SOFTKEYBOARD_TYPE_T1</TD>
<TD width=52%>Type T1 soft keyboard. This kind of soft keyboard should be updated by IMC_SETSOFTKBDDATA.</TD>
</TR>

<TR VALIGN="top">
<TD width=48%>SOFTKEYBOARD_TYPE_C1</TD>
<TD width=52%>Type C1 soft keyboard. This kind of soft keyboard should be updated by IMC_SETSOFTKBDDATA with two sets of 256-word array data. The first set is for nonshift state, and the second is for shift state.</TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>hOwner</I></DT>

<DD>Specifies the owner of the soft keyboard. It must be the UI window.</DD>

<DT><I>x</I></DT>

<DD>Specifies the initial horizontal position of the soft keyboard.</DD>

<DT><I>y</I></DT>

<DD>Specifies the initial vertical position of the soft keyboard.
</DD>
</DL>

<H4>Return Values</H4>

<P>This function returns the window handle of the soft keyboard.</P>

<H1>ImmDestroySoftKeyboard</H1>

<P>The <B>ImmDestroySoftKeyboard</B> function destroys the soft keyboard window.</P>

<PRE class=syntax><B>BOOL WINAPI</B>
  <B>ImmDestroySoftKeyboard(
</B>    <B>HWND  </B><I>hSoftKbdWnd<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hSoftKbdWnd</I></DT>

<DD>Window handle of the soft keyboard to destroy.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H1>ImmShowSoftKeyboard</H1>

<P>The <B>ImmShowSoftKeyboard</B> function shows or hides the given soft keyboard.</P>

<PRE class=syntax><B>BOOL WINAPI</B>
  <B>ImmShowSoftKeyboard(
</B>    <B>HWND  </B><I>hSoftKbdWnd<B>,
</B></I>    <B>int  </B><I>nCmdShow<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hSoftKbdWnd</I></DT>

<DD>Window handle of the soft keyboard.</DD>

<DT><I>nCmdShow</I></DT>

<DD>Shows the state of the window. The following values are provided.

<TABLE>

<TR VALIGN="top">
<TH align=left width=48%>NcmdShow</TH>
<TH align=left width=52%>Meaning</TH>
</TR>

<TR VALIGN="top">
<TD width=48%>SW_HIDE</TD>
<TD width=52%>Hides the soft keyboard.</TD>
</TR>

<TR VALIGN="top">
<TD width=48%>SW_SHOWNOACTIVATE</TD>
<TD width=52%>Displays the soft keyboard</TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H1>Messages</H1>

<P>The following topics contain the messages that the UI window receives.</P>

<H1>WM_IME_SETCONTEXT</H1>

<P>The <B>WM_IME_SETCONTEXT</B> message is sent to an application when a window of the application is being activated. If the application does not have an application IME window, the application has to pass this message to the <B>DefWindowProc</B> and should return the return value of the <B>DefWindowProc</B>. If the application has an application IME window, the application should call <B>ImmIsUIMessage</B>.</P>

<PRE class=syntax>WM_IME_SETCONTEXT
wParam (BOOL) = fSet; 
lParam = lISCBits; </PRE>

<H4>Parameters</H4>

<DL>
<DT><I>fSet</I></DT>

<DD>fSet is TRUE when the Input Context becomes active for the application. When it is FALSE, the Input Context becomes inactive for the application.</DD>

<DT><I>lISCBits</I></DT>

<DD><I>lISCBits</I> consists of the following bit combinations.

<TABLE>

<TR VALIGN="top">
<TH align=left width=63%>Value</TH>
<TH align=left width=37%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=63%>ISC_SHOWUICOMPOSITIONWINDOW</TD>
<TD width=37%>Shows the composition window.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>ISC_SHOWUIGUIDWINDOW</TD>
<TD width=37%>Shows the guide window.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>ISC_SHOWUICANDIDATEWINDOW</TD>
<TD width=37%>Shows the candidate window of Index 0.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>(ISC_SHOWUICANDIDATEWINDOW &lt;&lt; 1)</TD>
<TD width=37%>Shows the candidate window of Index 1.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>(ISC_SHOWUICANDIDATEWINDOW &lt;&lt; 2)</TD>
<TD width=37%>Shows the candidate window of Index 2.</TD>
</TR>

<TR VALIGN="top">
<TD width=63%>(ISC_SHOWUICANDIDATEWINDOW &lt;&lt; 3)</TD>
<TD width=37%>Shows the candidate window of Index 3.</TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<H4>Return Values</H4>

<P>The return value is the return value of <B>DefWindowProc</B> or <B>ImmIsUIMessage</B>.</P>

<H4>Comments</H4>

<P>After an application calls <B>DefWindowProc</B>( or <B>ImmIsUIMessage</B> with WM_IME_SETCONTEXT, the UI window receives WM_IME_SETCONTEXT. If the bit is on, the UI window shows the composition, guide, or candidate window as the bit status of <I>lParam</I>.</P>

<P>If an application draws the composition window by itself, the UI window does not need to show its composition window. The application then has to clear the ISC_SHOWUICOMPOSITIONWINDOW bit of <I>lParam</I> and call <B>DefWindowProc</B> or <B>ImmIsUIMessage</B> with it.</P>

<H1>WM_IME_CONTROL</H1>

<P>The <B>WM_IME_CONTROL</B> message is a group of sub messages used to control the IME User Interface. An application uses this message to interact with the IME window created by the application.</P>

<PRE class=syntax>WM_IME_CONTROL
wParam = wSubMessage ;
lParam(LPVOID) = lpData;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>wSubMessage</I></DT>

<DD>Submessage value.</DD>

<DT><I>LpData</I></DT>

<DD>Dependent on each <I>wSubMessage.</I> 
</DD>
</DL>

<P>The following topics contain the submessages classified by the <I>wSubMessage </I>value.</P>

<P>Except for IMC_GETSOFTKBDSUBTYPE, IMC_SETSOFTKBDSUBTYPE, IMC_SETSOFTKBDDATA, IMC_GETSOFTKBDFONT, IMC_SETSOFTKBDFONT, IMC_GETSOFTKBDPOS and IMC_SETSOFTKBDPOS, it is recommended that applications use IMM APIs instead of the IMC messages to communicate with the IME window. </P>

<H1>IMC_GETCANDIDATEPOS</H1>

<P>The <B>IMC_GETCANDIDATEPOS</B> message is sent by an application to the IME window<I> </I>to get the position of the candidate window. The IME can adjust the position of a candidate window in respect to the screen boundary. In addition, an application can obtain the real position of a candidate window to determine whether to move it to another position.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_GETCANDIDATEPOS = wSubMessage;
lParam(LPCANDIDATEFORM) = lpCANDIDATENFORM;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpCANDIDATENFORM</I><B> </B></DT>

<DD>Buffer to retrieve the position of the candidate window.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>In return, the IME will fill the <B>CANDIDATEFORM</B> pointed to by <I>lpCANDIDATENFORM</I><B> </B>with the client coordinates of the application’s focus window. The UI window receives this message. An application should specify <I>lpCANIDATEFORM</I>-&gt;dwIndex to 0 ~ 3 to obtain a different candidate window position. (For example, index 0 is a top-level candidate window.)</P>

<H1>IMC_GETCOMPOSITONFONT</H1>

<P>The <B>IMC_GETCOMPOSITONFONT</B> message is sent by an application to the IME window<I> </I>to obtain the font to use in displaying intermediate characters in the composition window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_GETCOMPOSITIONFONT = wSubMessage;
(LPLOGFONT)lParam = lpLogFont;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpLogFont</I></DT>

<DD>Buffer to retrieve the LOGFONT.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The UI window does not receive this message.</P>

<H1>IMC_GETCOMPOSITONWINDOW</H1>

<P>The <B>IMC_GETCOMPOSITONWINDOW</B> message is sent by an application to the IME window to get the position of the composition window. An IME can adjust the position of a composition window, and an application can obtain the real position of composition window to determine whether to move it to another position.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_GETCOMPOSITIONWINDOW = wSubMessage;
lParam(LPCOMPOSITIONFORM) = lpCOMPOSITIONFORM;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpCOMPOSITIONFORM</I></DT>

<DD>Buffer to retrieve the position of the composition window.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>In return, the IME will fill the <B>CANDIDATEFORM</B> pointed to by <I>lpCANDIDATENFORM</I> with the client coordinates of the application’s focus window. The UI window receives this message.</P>

<H1>IMC_GETSOFTKBDFONT</H1>

<P>The <B>IMC_GETSOFTKBDFONT</B> message is sent by the IME to the soft keyboard window<I> </I>to obtain the font to use for character display in the soft keyboard window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_GETSOFTKBDFONT = wSubMessage;
lParam(LPLOGFONT) = lpLogFont;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpLogFont</I></DT>

<DD>Buffer to retrieve the LOGFONT.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H1>IMC_GETSOFTKBDPOS</H1>

<P>The <B>IMC_GETSOFTKBDPOS</B> message is sent by an IME to the soft keyboard window to obtain the position of the soft keyboard window.</P>

<PRE class=syntax>WM_IME_CONTROL
wSubMessage= IMC_GETSOFTKBDPOS;
lParam = 0;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value specifies a <B>POINTS</B> structure that contains the <I>x</I> and <I>y </I>coordinates of the position of the soft keyboard window, in screen coordinates.</P>

<H4>Comments</H4>

<P>The <B>POINTS</B> structure has the following form:</P>

<PRE>typedef struct tagPOINTS { /* pts */
SHORT x;
SHORT y;
} POINTS;</PRE>

<H1>IMC_GETSOFTKBDSUBTYPE</H1>

<P>The <B>IMC_GETSOFTKBDSUBTYPE</B> message is sent by an IME to the soft keyboard window to obtain the subtype of the soft keyboard window set by <B>IMC_SETSOFTKBDSUBTYPE</B>.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_GETSOFTKBDSUBTYPE = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value is the subtype of the soft keyboard set by <B>IMC_SETSOFTKBDSUBTYPE</B>. A return value of -1 indicates failure.</P>

<H1>IMC_GETSTATUSWINDOWPOS</H1>

<P>The <B>IMC_GETSTATUSWINDOWPOS</B> message is sent by an application to the IME window to get the position of the status window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_GETSTATUSWINDOWPOS = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value specifies a <B>POINTS</B> structure that contains the <I>x </I>and <I>y </I>coordinates of the position of the status window, in screen coordinates.</P>

<H4>Comments</H4>

<P>The <B>POINTS</B> structure has the following form:</P>

<PRE>typedef struct tagPOINTS { /* pts */
SHORT x;
SHORT y;
} POINTS;</PRE>

<P>The UI window receives the message.</P>

<H1>IMC_SETCANDIDATEPOS</H1>

<P>The <B>IMC_SETCANDIDATEPOS</B> message is sent by an application to the IME window to specify the display position of a candidate window. In particular, this applies to an application that displays composition characters by itself, but uses the IME UI to display candidates.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETCANDIDATEPOS = wSubMessage= ;
lParam(LPCANDIDATEFORM) = lpCANDIDATEFORM;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpCANDIDATEFORM</I></DT>

<DD>Buffer includes the candidate window position information.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The UI window does not receive this message.</P>

<H1>IMC_SETCOMPOSITONFONT</H1>

<P>The <B>IMC_SETCOMPOSITONFONT</B> message is sent by an application to the IME window to specify the font to use in displaying intermediate characters in the composition window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETCOMPOSITIONFONT = wSubMessage;
lParam(LPLOGFONT) = lpLogFont;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpLogFont</I></DT>

<DD>Buffer includes the LOGFONT data to set.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The UI window does not receive this message.</P>

<H1>IMC_SETCOMPOSITONWINDOW</H1>

<P>The <B>IMC_SETCOMPOSITONWINDOW</B> message is sent by an application to the IME window to set the style of the composition window in the current active Input Context. Once an application sets the style, the IME user interface then follows the style specified in the Input Context.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETCOMPOSITIONWINDOW  =SubMessage;
lParam(LPCOMPOSITIONFORM) = lpCOMPOSITIONFORM;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpCOMPOSITIONFORM </I></DT>

<DD><B>COMPOSITIONFORM</B> structure includes the new styles for the composition window.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The IME user interface uses a default style for the composition window that is equal to the CFS_POINT style. If an application has not specified a composition style in its Input Context, the IME user interface retrieves the current caret position and window client area when it opens the composition window (in client coordinates). The UI window does not receive this message.</P>

<H1>IMC_SETSOFTKBDDATA</H1>

<P>The <B>IMC_SETSOFTKBDDATA</B> message is sent by the IME to the soft keyboard window to specify the character code to use for displaying characters in the soft keyboard window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETSOFTKBDDATA = wSubMessage;
lParam(LPSOFTKBDDATA) = lpSoftKbdData;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpSoftKbdData </I></DT>

<DD>Points to the buffer to specify the character code to use for displaying characters.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The UI window does not receive this message.</P>

<H1>IMC_SETSOFTKBDSUBTYPE</H1>

<P>The <B>IMC_SETSOFTKBDSUBTYPE</B> message is sent by the IME to the soft keyboard window to specify the subtype to use for displaying characters in the soft keyboard window. It also can be used for IME-specific purposes.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETSOFTKBDSUBTYPE = wSubMessage;
lParam = lSubType;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lSubType</I></DT>

<DD>Specifies the subtype to set.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value is the subtype. A return value of -1 indicates failure.</P>

<H4>Comments</H4>

<P>The UI window does not receive this message, and the SOFTKEYBOARD_TYPE_T1 does not use this information. The IME sends this message so the soft keyboard will not change the displayed reading characters. The IME can use the SOFTKEYBOARD_TYPE_T1 soft keyboard to define the meaning of this message and can obtain this data by using IMC_GETSOFTKBDSUBTYPE.</P>

<H1>IMC_SETSOFTKBDFONT</H1>

<P>The <B>IMC_SETSOFTKBDFONT</B> message is sent by the IME to the soft keyboard window to specify the font to use in displaying characters in the soft keyboard window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETSOFTKBDFONT = wSubMessage;
lParam(LPLOGFONT) = lpLogFont;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpLogFont </I></DT>

<DD>Points to the LOGFONT to be set.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The UI window does not receive this message.</P>

<H1>IMC_SETSOFTKBDPOS</H1>

<P>The <B>IMC_SETSOFTKBDPOS</B> message is sent by the UI window to soft keyboard window to set the position of the soft keyboard window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETSOFTKBDPOS = wSubMessage;
lParam(POINTS) = ptsPt;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>ptsPt</I></DT>

<DD>Specifies a <B>POINTS</B> structure that contains the <I>x</I> and <I>y </I>coordinates of the position of the soft keyboard window, in screen coordinates.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The <B>POINTS</B> structure has the following form:</P>

<PRE>typedef struct tagPOINTS { /* pts */
SHORT x;
SHORT y;
} POINTS;</PRE>

<H1>IMC_SETSTATUSWINDOWPOS</H1>

<P>The <B>IMC_SETSTATUSWINDOWPOS</B> message is sent by an application to the IME window to set the position of the status window.</P>

<PRE class=syntax>WM_IME_CONTROL
IMC_SETSTATUSWINDOWPOS = wSubMessage;
lParam(POINTS) = ptsPt;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>ptsPt</I></DT>

<DD>Specifies a <B>POINTS</B> structure that contains the <I>x </I>and <I>y</I> coordinates of the position of the status window, in screen coordinates.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the message is successful, the return value is zero. Otherwise, the return value is nonzero.</P>

<H4>Comments</H4>

<P>The <B>POINTS</B> structure has the following form:</P>

<PRE>typedef struct tagPOINTS { /* pts */
SHORT x;
SHORT y;
} POINTS;</PRE>

<H1>WM_IME_COMPOSITION </H1>

<P>The <B>WM_IME_COMPOSITION</B> message is sent to an application when the IME composition status is changed (by the user). The message consists of two bytes of composition character. The IME user interface window changes its appearance when it processes this message. An application can call <B>ImmGetCompositionString </B>to obtain the new composition status.</P>

<PRE class=syntax>WM_IME_COMPOSITION
wParam = wChar;
lParam = lAttribute;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>wChar</I></DT>

<DD>Consists of two bytes of DBCS character that is the latest change of composition character.</DD>

<DT><I>lAttribute</I></DT>

<DD>Contains the following flag combinations. Basically, the flag indicates how the composition string or character has changed. An application checks this to retrieve necessary information.

<TABLE>

<TR VALIGN="top">
<TH align=left width=45%>Value</TH>
<TH align=left width=55%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=45%>GCR_ERRORSTR</TD>
<TD width=55%>Updates the error string.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCR_INFORMATIONSTR</TD>
<TD width=55%>Updates the information string.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_COMPATTR</TD>
<TD width=55%>Updates the attribute of the composition string.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_COMPCLAUSE</TD>
<TD width=55%>Updates clause information of the composition string.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_COMPREADATTR</TD>
<TD width=55%>Updates the attributes of the reading string of the current composition.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_COMPREADCLAUSE</TD>
<TD width=55%>Updates the clause information of the reading string of the composition string.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_COMPREADSTR</TD>
<TD width=55%>Updates the reading string of the current composition. </TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_COMPSTR</TD>
<TD width=55%>Updates the current composition string. </TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_CURSORPOS</TD>
<TD width=55%>Updates the cursor position in composition string.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_DELTASTART</TD>
<TD width=55%>Updates the starting position of any changes in composition string.</TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_RESULTCLAUSE</TD>
<TD width=55%>Updates clause information of the result string. </TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_RESULTREADCLAUSE</TD>
<TD width=55%>Updates clause information of the reading string. </TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_RESULTREADSTR</TD>
<TD width=55%>Updates the reading string. </TD>
</TR>

<TR VALIGN="top">
<TD width=45%>GCS_RESULTSTR</TD>
<TD width=55%>Updates the string of the composition result. </TD>
</TR>
</TABLE><BR>



<P>The following style bit values are provided for WM_IME_COMPOSITION.


<TABLE>

<TR VALIGN="top">
<TH align=left width=36%>Value</TH>
<TH align=left width=64%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=36%>CS_INSERTCHAR</TD>
<TD width=64%>An IME specifies this value when <I>wParam</I> shows a composition character that should be inserted into the current insertion point. An application should display a composition character if it processes this bit flag.</TD>
</TR>

<TR VALIGN="top">
<TD width=36%>CS_NOMOVECARET</TD>
<TD width=64%>An IME specifies this value when it does not want an application to move the caret position as a result of processing WM_IME_COMPOSITION. For example, if an IME specifies a combination of CS_INSERTCHAR and CS_NOMOVECARET, it means that an application should insert a character given by <I>wParam</I> to the current caret position, but should not move the caret. Subsequent WM_IME_COMPOSITION messages containing the GCS_RESULTSTR flag will replace this character.</TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>When an application wants to display composition characters by themselves, it should not pass this message to the application IME user interface window<I> </I>or to <B>DefWindowProc</B>. The <B>DefWindowProc</B> function processes this message to pass to the Default IME window. An IME should send this message to an application even when the IME only cancels the current composition. This message should also be used to notify an application or IME UI to erase the current composition string.</P>

<H4>See Also</H4>

<P><B>ImmGetCompositionString</B></P>

<H1>WM_IME_COMPOSITIONFULL</H1>

<P>The <B>WM_IME_COMPOSITIONFULL </B>message is sent to an application when the IME user interface window cannot increase the size of the composition window. An application should specify how to display the IME UI window when it receives this message.</P>

<PRE class=syntax>WM_IME_COMPOSITIONFULL
0 = wParam
0 = lParam</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>wParam</I></DT>

<DD>Not used.</DD>

<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>This message is a notification, which is sent to an application by the IME user interface window and not by the IME itself. The IME uses <B>SendMEssage</B> to send this notification.</P>

<H4>See Also</H4>

<P><B>IMC_SETCOMPOSITONWINDOW</B></P>

<H1>WM_IME_ENDCOMPOSITION</H1>

<P>The <B>WM_IME_ENDCOMPOSITION</B> message is sent to an application when the IME ends composition.</P>

<PRE class=syntax>WM_IME_ENDCOMPOSITION
0 = wParam
0 = lParam</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>wParam</I></DT>

<DD>Not used.</DD>

<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>When an application wants to display composition characters by themselves, it should not pass this message to the application IME UI window or to <B>DefWindowProc</B>. <B>DefWindowProc</B> processes this message to pass it to the default IME window<I>.</I></P>

<H1>WM_IME_SELECT</H1>

<P>The <B>WM_IME_SELECT</B> message is sent to the UI window when the system is about to change the current IME.</P>

<PRE class=syntax>WM_IME_SELECT
wParam(BOOL) = fSelect
lParam = hKL</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>fSelect</I></DT>

<DD>TRUE if the IME is newly selected. Otherwise, it is FALSE if the IME is unselected.</DD>

<DT><I>hKL</I></DT>

<DD>Input language handle of the IME. 
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The system IME class uses this message to create a new UI window and destroy an old UI window for an application or system. <B>DefWindowProc</B> processes this message to pass the information to the default IME window. The default IME window then sends this message to its UI window.</P>

<H1>WM_IME_STARTCOMPOSITION</H1>

<P>The <B>WM_IME_STARTCOMPOSITION</B> message is sent immediately before an IME generates a composition string as a result of a user’s keystroke. The UI window opens its composition window when it receives this message.</P>

<PRE class=syntax>WM_IME_STARTCOMPOSITION
0 = wParam
0 = lParamx</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>wParam</I></DT>

<DD>Not used.</DD>

<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>When an application wants to display composition characters by themselves, it should not pass this message to the application IME window or to <B>DefWindowProc</B>. The <B>DefWindowProc</B> function processes this message to pass it to the default IME window.</P>

<H1>WM_IME_NOTIFY</H1>

<P>The <B>WM_IME_NOTIFY</B> message is a group of submessages that notifies an application or UI window of the IME status. </P>

<PRE class=syntax>WM_IME_NOTIFY
wSubMessage= wParam; //submessage ID
lParam= lParam; // depends on the submessage</PRE>

<P>The following topics contain the submessages classified by the value of <I>wSubMessage</I>. </P>

<H1>IMN_CLOSESTATUSWINDOW</H1>

<P>The <B>IMN_CLOSESTATUSWINDOW</B> message is sent when an IME is about to close a status window. </P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_CLOSESTATUSWINDOW = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window closes the status window when it receives this message.</P>

<H1>IMN_OPENSTATUSWINDOW</H1>

<P>The <B>IMN_OPENSTATUSWINDOW</B> message is sent when an IME is about to create a status window. An application then processes this message and displays a system window for the IME itself.</P>

<P>An application can obtain information about the system window by calling the <B>ImmGetConversionStatus</B> function.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_OPENSTATUSWINDOW = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window creates a status window when it receives this message. </P>

<H4>See Also</H4>

<P><B>ImmGetConversionStatus</B></P>

<H1>IMN_OPENCANDIDATE</H1>

<P>The <B>IMN_OPENCANDIDATE</B> message is sent when an IME is about to open a candidate window. An application then processes this message and calls <B>ImmGetCandidateCount</B> and <B>ImmGetCandidateList</B> to display the candidate window itself.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_OPENCANDIDATE = wSubMessage;
lParam = lCandidateList;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lCandidateList</I></DT>

<DD>Shows which candidate list should be updated. For example, if bit 0 is 1, the first candidate list should be updated. If bit 31 is 1, the 32nd candidate list should be updated.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window creates a candidate window when it receives this message. </P>

<H4>See Also</H4>

<P>ImmGetCandidateListCount, ImmGetCandidateList, WM_IME_CHANGECANDIDATE</P>

<H1>IMN_CHANGECANDIDATE</H1>

<P>The<B> IMN_CHANGECANDIDATE</B> message is sent when an IME is about to change the content of a candidate window. An application then processes this message to display the candidate window itself.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_CHANGECANDIDATE = wSubMessage;
lParam = lCandidateList;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lCandidateList</I></DT>

<DD>Shows which candidate list should be updated. For example, if bit 0 is 1, the first candidate list should be updated. If bit 31 is 1, the 32nd candidate list should be updated.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window redraws a candidate window when it receives this message. </P>

<H4>See Also</H4>

<P><B>ImmGetCandidateCount</B>, <B>ImmGetCandidateList</B></P>

<H1>IMN_CLOSECANDIDATE</H1>

<P>The <B>IMN_CLOSECANDIDATE</B> message is sent when an IME is about to close a candidate window. An application processes this message to obtain information about the end of candidate processing. </P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_CLOSECANDIDATE = wSubMessage;
lParam = lCandidateList;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lCandidateList</I></DT>

<DD>Shows which candidate list should be closed. For example, if bit 0 is 1, the first candidate list should be updated. If bit 31 is 1, the 32nd candidate list should be updated.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window destroys a candidate window when it receives this message.</P>

<H1>IMN_SETCONVERSIONMODE</H1>

<P>The <B>IMN_SETCONVERSIONMODE</B> message is sent when the conversion mode of the Input Context is updated. When the application or UI window receives this message, either one can call <B>ImmGetConversionStatus</B> to obtain information about the status window.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_SETCONVERSIONMODE = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window redraws the status window if the status window shows the conversion mode.</P>

<H1>IMN_SETSENTENCEMODE</H1>

<P>The <B>IMN_SETSENTENCEMODE</B> message is sent when the sentence mode of the Input Context is updated. When the application or UI window receives this message, either one can call <B>ImmGetConversionStatus</B> to obtain information about the status window.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_SETSENTENCEMODE = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window redraws the status window if the status window shows the sentence mode.</P>

<H1>IMN_SETOPENSTATUS</H1>

<P>The <B>IMN_SETOPENSTATUS</B> message is sent when the open status of the Input Context is updated. When the application or UI window receives this message, either one can call <B>ImmGetOpenStatus</B> to obtain information.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_SETOPENSTATUS = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window redraws the status window if the status window shows the open/close status.</P>

<H1>IMN_SETCANDIDATEPOS</H1>

<P>The<B> IMN_SETCANDIDATEPOS</B> message is sent when an IME is about to move the candidate window. An application processes this message to obtain information about the end of candidate processing.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_SETCANDIDATEPOS = wSubMessage;
lParam = lCandidateList;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lCandidateList</I></DT>

<DD>Shows which candidate list should be moved. For example, if bit 0 is 1, the first candidate list should be updated. If bit 31 is 1, the 32nd candidate list should be updated.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window moves a candidate window when it receives this message.</P>

<H1>IMN_SETCOMPOSITIONFONT</H1>

<P>The <B>IMN_SETCOMPOSITIONFONT</B> message is sent when the font of the Input Context is updated. When the application or UI window receives this message, either one can call <B>ImmGetCompositionFont</B> to obtain information about the composition font.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_SETCOMPOSITIONFONT = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The composition component of the UI window uses the font information by calling <B>ImmGetCompositionFont</B> to draw the text of the composition string.</P>

<H1>IMN_SETCOMPOSITIONWINDOW</H1>

<P>The <B>IMN_SETCOMPOSITIONWINDOW</B> message is sent when the composition form of the Input Context is updated. When the UI window receives this message, the <I>cfCompForm</I> of the Input Context can be referenced to obtain the new conversion mode.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_SETCOMPOSITIONWINDOW = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The composition component of the UI window uses <I>cfCompForm</I> to show the composition window.</P>

<H1>IMN_GUIDELINE</H1>

<P>The <B>IMN_GUIDELINE</B> message is sent when an IME is about to show an error or information. When the application or UI window receives this message, either one can call <B>ImmGetGuideLine</B> to obtain information about the guideline. </P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_GUIDELINE = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used. Has to be zero.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>The UI window can create an information window when it receives this message and show the information string. </P>

<H4>See Also</H4>

<P><B>ImmGetGuideLine</B>, <B>GUIDELINE</B> structure</P>

<H1>IMN_SOFTKBDDESTROYED</H1>

<P>The <B>IMN_SOFTKBDDESTROYED</B> message is sent to the UI window when the soft keyboard is destroyed.</P>

<PRE class=syntax>WM_IME_NOTIFY
IMN_SOFTKBDDESTROYED = wSubMessage;
0 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Not used. Has to be zero.
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H1>WM_IME_KEYDOWN and WM_IME_KEYUP</H1>

<P>The <B>WM_IME_KEYDOWN</B> and <B>WM_IME_KEYUP</B> messages are sent to an application when an IME needs to generate a <B>WM_KEYDOWN</B> or <B>WM_KEYUP</B> message. The value sent is the same as the original Windows <B>WM_KEYDOWN</B> and <B>WM_KEYUP</B> value (English version).</P>

<PRE class=syntax>WM_IME_KEYDOWN / WM_IME_KEYUP
 wParam(int) = nVirtKey; // virtual-key code 
lParam = lKeyData; // key data </PRE>

<H4>Parameters </H4>

<DL>
<DT><I>nVirtKey</I> </DT>

<DD>Value of <I>wParam</I>. Specifies the virtual key code of the nonsystem key. </DD>

<DT><I>lKeyData</I> </DT>

<DD>Value of <I>lParam</I>. Specifies the repeat count, scan code, extended key flag, context code, previous key state flag, and transition state flag. It is the same as for the original Windows <B>WM_KEYDOWN</B> and <B>WM_KEYUP</B> messages
</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>An application can handle this message the same way as the <B>WM_KEYDOWN</B> and <B>WM_KEYUP</B> message. Otherwise, <B>DefWindowProc</B> processes this message to generate a <B>WM_KEYDOWN</B> or <B>WM_KEYUP</B> message with the same <I>wParam</I> and <I>lParam</I> parameters. This message is usually generated by the IME to maintain message order.</P>

<H1>WM_IME_CHAR</H1>

<P>The <B>WM_IME_CHAR</B> message is sent to an application when the IME gets a character of the conversion result. The value that is sent is similar to the original Windows <B>WM_CHAR</B> (English version). The difference is that <I>wParam</I> can include two bytes of character. </P>

<PRE class=syntax>WM_IME_CHAR
wParam = wCharCode;
lParam = lKeyData;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>wCharCode</I></DT>

<DD>Includes two bytes for an FE character. For NT Unicode application, it includes one Unicode character.</DD>

<DT><I>lKeyData</I></DT>

<DD>Same as the original Windows <B>WM_CHAR</B> (English Version). Following are the available bits and their description.

<TABLE>

<TR VALIGN="top">
<TH align=left width=19%>Value</TH>
<TH align=left width=81%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=19%> 0 – 15</TD>
<TD width=81%>Repeat count. Since the first byte and second byte are continuous, this is always 1.</TD>
</TR>

<TR VALIGN="top">
<TD width=19%>16 – 23</TD>
<TD width=81%>Scan Code. Scan code for a complete FE character<B>.</B></TD>
</TR>

<TR VALIGN="top">
<TD width=19%>24 – 28</TD>
<TD width=81%>Not used.</TD>
</TR>

<TR VALIGN="top">
<TD width=19%>29</TD>
<TD width=81%>Context code.</TD>
</TR>

<TR VALIGN="top">
<TD width=19%>31</TD>
<TD width=81%>Conversion state.</TD>
</TR>
</TABLE><BR>


</DD>
</DL>

<H4>Return Values</H4>

<P>None</P>

<H4>Comments</H4>

<P>If the application does not handle this message, the <B>DefWindowProc</B> function processes this message to generate <B>WM_CHAR</B> messages. If the application is not Unicode based and <I>wCharCode</I> includes 2 bytes of DBCS character, the <B>DefWindowProc</B> function will generate two WM_CHAR messages, each message containing 1 byte of the DBCS character. If the message just includes an SBCS character, <B>DefWindowProc</B> generates only one <B>WM_CHAR</B> message.</P>

<H1>VK_PROCESSKEY</H1>

<P>The <B>VK_PROCESSKEY</B> message is sent to an application as a <I>wParam</I> of <B>WM_KEYDOWN</B> or <B>WM_KEYUP</B>. When this virtual key is generated, either the real virtual key is saved in the Input Context or the messages that were generated by IME are stored in the Input Context. The system either restores the real virtual key or posts the messages that are stored in the message buffer of the Input Context.</P>

<PRE class=syntax>WM_KEYDOWN /WM_KEYUP
VK_PROCESSKEY = wParam;
1 = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lParam</I></DT>

<DD>Must be 1.
</DD>
</DL>

<H1>INDICM_SETIMEICON</H1>

<P>This message is sent to the Indicator window when the IME wants to change the icon for System Pen icon. This message can be accepted when the selected <I>hKL</I> of the focused window is the same as the sender IME.</P>

<PRE class=syntax>INDICM_SETIMEICON
wParam = nIconIndex;
hKL = lParam;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>nIconIdex</I></DT>

<DD>Index for the icon resource of the IME file. If this value is (-1), the Indicator restores the original icon provided by the system.</DD>

<DT><I>lKey</I></DT>

<DD><I>hKL</I> that is the sender IME.
</DD>
</DL>

<H4>Return Values</H4>

<P>A nonzero value indicates failure. Otherwise, zero is returned.</P>

<H4>Comments</H4>

<P>Due to the internal design requirement in the task bar manager, the IME must use <B>PostMessage</B> for INDICM_xxx messages.</P>

<H1>INDICM_SETIMETOOLTIPS</H1>

<P>This message is sent to the Indicator window when the IME wants to change the Tooltip string for the System Pen icon. This message can be accepted when the selected <I>hKL</I> of the focused window is the same as the sender IME.</P>

<PRE class=syntax>INDICM_SETIMETOOLTIPS
wParam = hAtom;
lParam = hKL;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hAtom</I></DT>

<DD>Global ATOM value for the Tooltip string. If this value is (-1), the Indicator restores the original tips provided by the system.</DD>

<DT><I>lKey</I></DT>

<DD><I>hKL</I> that is the sender IME.
</DD>
</DL>

<H4>Return Values</H4>

<P>A nonzero indicates failure. Otherwise, zero is returned.</P>

<H4>Comments</H4>

<P>Due to the internal design requirement in the task bar manager, the IME must use <B>PostMessage</B> for INDICM_xxx messages. The global ATOM must be retrieved by <B>GlobalAddAtom</B> or <B>GlobalFindAtom</B>.</P>

<H1>INDICM_REMOVEDEFAULTMENUITEMS</H1>

<P>This message is sent to the Indicator window when the IME wants to remove the default menu items of the System Pen icon.</P>

<PRE class=syntax>INDICM_REMOVEDEFAULTMENUITEMS
wParam = wValue;
lParam = hKL;</PRE>

<H4>Parameters</H4>

<DL>
<DT><I>wValue</I></DT>

<DD><I>wValue</I> is a combination of the following bits.

<TABLE>

<TR VALIGN="top">
<TH align=left width=26%>Value</TH>
<TH align=left width=74%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=26%>RDMI_LEFT</TD>
<TD width=74%>Removes the menu items of the left click menu.</TD>
</TR>

<TR VALIGN="top">
<TD width=26%>RDMI_RIGHT</TD>
<TD width=74%>Removes the menu items of the right click menu.</TD>
</TR>
</TABLE><BR>



<P>If <I>wValue</I> is zero, all default menu items are restored.
</DD>

<DT><I>lKey</I></DT>

<DD><I>hKL</I> that is the sender IME.
</DD>
</DL>

<H4>Return Values</H4>

<P>A nonzero indicates failure. Otherwise, zero is returned.</P>

<H4>Comments</H4>

<P>Due to the internal design requirement in the task bar manager, the IME must use <B>PostMessage</B> for INDICM_xxx messages. </P>

<H1>IME Interface Functions</H1>

<P>IMEs are provided as dynamic-link libraries (DLLs). The Input Method Manager (IMM) should handle all installed IMEs. Because IMEs are changeable at run time without rebooting, the IMM will have a structure to maintain all the entry points of each IME.</P>

<P>The following topics contain all the common IME functions. These functions should not be called by an application directly.</P>

<H1>ImeInquire</H1>

<P><B><U>For Windows 95, Windows 98, and Windows NT 3.51</U></B></P>

<P>The <B>ImeInquire</B> function handles initialization of the IME. It also returns an <B>IMEINFO</B> structure and the UI class name of the IME.</P>

<PRE class=syntax><B>BOOL
  ImeInquire(
</B>    <B>LPIMEINFO</B>  <I>lpIMEInfo</I>,
    <B>LPTSTR</B>  <I>lpszWndClass</I>,
    <B>LPCTSTR</B>  <I>lpszData</I>
<B>    )</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpIMEInfo</I></DT>

<DD>Pointer to the IME info structure.</DD>

<DT><I>lpszWndClass</I></DT>

<DD>Window class name that should be filled by the IME. This name is the IME’s UI class. </DD>

<DT><I>lpszData</I></DT>

<DD>IME option block. NULL for this version.
</DD>
</DL>

<P><B><U>For Windows NT 4.0 and Windows 2000</U></B></P>

<PRE class=syntax><B>BOOL
</B>  <B>ImeInquire(
</B>    <B>LPIMEINFO  </B><I>lpIMEInfo</I><B>,
</B>    <B>LPTSTR </B><I>lpszWndClass</I><B>,
</B>    <B>DWORD  </B><I>dwSystemInfoFlags</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpIMEInfo</I></DT>

<DD>Pointer to the IME info structure.</DD>

<DT><I>lpszWndClass</I></DT>

<DD>Window class name that should be filled by the IME. This name is the IME’s UI class. </DD>

<DT><I>dwSystemInfoFlags</I></DT>

<DD>Varying system information provided by the system. The following flags are provided.

<TABLE>

<TR VALIGN="top">
<TH align=left width=48%>Flag</TH>
<TH align=left width=52%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=48%>IME_SYSINFO_WINLOGON</TD>
<TD width=52%>Tells the IME that the client process is the Winlogon process. The IME should not allow users to configure the IME when this flag is specified.</TD>
</TR>

<TR VALIGN="top">
<TD width=48%>IME_SYSINFO_WOW16</TD>
<TD width=52%>Tells the IME that the client process is a 16-bit application.</TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H1>ImeConversionList</H1>

<P>The <B>ImeConversionList</B> function obtains a converted result list from another character or string.</P>

<PRE class=syntax><B>DWORD
</B>  <B>IMEConversionList(
</B>    <B>HIMC  </B><I>hIMC</I><B>,
</B>    <B>LPCTSTR  </B><I>lpSrc</I><B>,
</B>    <B>LPCANDIDATELIST  </B><I>lpDst</I><B>,
</B>    <B>DWORD  </B><I>dwBufLen</I><B>,
</B>    <B>UINT  </B><I>uFlag</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle.</DD>

<DT><I>lpSrc</I></DT>

<DD>Character string to be converted.</DD>

<DT><I>lpDst</I></DT>

<DD>Pointer to the destination buffer.</DD>

<DT><I>dwBufLen</I></DT>

<DD>Length of the destination buffer.</DD>

<DT><I>uFlag</I></DT>

<DD>Currently can be one of the following three flags.

<TABLE>

<TR VALIGN="top">
<TH align=left width=48%>Flag</TH>
<TH align=left width=52%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=48%>GCL_CONVERSION</TD>
<TD width=52%>Specifies the reading string to the <I>lpSrc</I> parameter. The IME returns the result string in the <I>lpDst</I> parameter.</TD>
</TR>

<TR VALIGN="top">
<TD width=48%>GCL_REVERSECONVERSION</TD>
<TD width=52%>Specifies the result string in the <I>lpSrc</I> parameter. The IME returns the reading string in the <I>lpDst</I> parameter.</TD>
</TR>

<TR VALIGN="top">
<TD width=48%>GCL_REVERSE_LENGTH</TD>
<TD width=52%>Specifies the result string in the <I>lpSrc</I> parameter. The IME returns the length that it can handle in GCL_REVERSECONVERSION. For example, an IME cannot convert a result string with a sentence period to a reading string. As a result, it returns the string length in bytes without the sentence period.</TD>
</TR>
</TABLE><BR>

</DD>
</DL>

<H4>Return Values</H4>

<P>The return value is the number of bytes of the result string list.</P>

<H4>Comments</H4>

<P>This function is intended to be called by an application or an IME without generating IME-related messages. Therefore, an IME should not generate any IME-related messages in this function.</P>

<H1>ImeConfigure</H1>

<P>The <B>ImeConfigure</B> function provides a dialog box to use to request optional information for an IME.</P>

<PRE class=syntax><B>BOOL
</B>  <B>ImeConfigure(
</B>    <B>HKL  </B><I>hKL</I><B>,
</B>    <B>HWND  </B><I>hWnd</I><B>,
</B>    <B>DWORD  </B><I>dwMode</I><B>,
</B>    <B>LPVOID  </B><I>lpData</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hKL</I></DT>

<DD>Input language handle of this IME.</DD>

<DT><I>hWnd</I></DT>

<DD>Parent window handle.</DD>

<DT><I>dwMode</I></DT>

<DD>Mode of dialog. The following flags are provided.

<TABLE>

<TR VALIGN="top">
<TD width=54%><B>Flag</B></TD>
<TD width=46%><B>Description</B></TD>
</TR>

<TR VALIGN="top">
<TD width=54%>IME_CONFIG_GENERAL</TD>
<TD width=46%>Dialog for general purpose configuration. </TD>
</TR>

<TR VALIGN="top">
<TD width=54%>IME_CONFIG_REGWORD</TD>
<TD width=46%>Dialog for register word. </TD>
</TR>

<TR VALIGN="top">
<TD width=54%>IME_CONFIG_SELECTDICTIONARY</TD>
<TD width=46%>Dialog for selecting the IME dictionary. </TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>lpData</I></DT>

<DD>Pointer to VOID, which will be a pointer to the <B>REGISTERWORD</B> structure only if dwMode==IME_CONFIG_REGISTERWORD. Otherwise, <I>lpData</I> should just be ignored.

<P>This also can be NULL with the IME_CONFIG_REGISTER mode, if no initial string information is given.

</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H4>Comments</H4>

<P>An IME checks <I>lpData</I> in the following way in the pseudo code.</P>

<PRE>if (dwmode != IME_CONFIG_REGISTERWORD)
    {
// Does original execution
    }
else if (IsBadReadPtr(lpdata, sizeof(REGISTERWORD))==FALSE)
    {
 
if (IsBadStringPtr(PREGISTERWORD(lpdata)-&gt;lpReading, (UINT)-1)==FALSE)
    {
// Set the reading string to word registering dialogbox
    }
if (IsBadStringPtr(PREGISTERWORD(lpdata)-&gt;lpWord, (UINT)-1)==FALSE)
    {
// Set the word string to word registering dialogbox
    }
    }</PRE>

<H1>ImeDestroy</H1>

<P>The <B>ImeDestroy</B> function terminates the IME itself. </P>

<PRE class=syntax><B>BOOL
</B>  <B>ImeDestroy(
</B>    <B>UINT  </B><I>uReserved<B>
</B></I>    <B>) </B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>uReserved</I></DT>

<DD>Reserved. Currently, it should be zero. For this version, the IME should return FALSE if it is not zero.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H1>ImeEscape</H1>

<P>The <B>ImeEscape</B> function allows an application to access capabilities of a particular IME not directly available though other IMM functions. This is necessary mainly for country/region-specific functions or private functions in the IME. </P>

<PRE class=syntax><B>LRESULT
</B>  <B>ImeEscape(
</B>    <B>HIMC  </B><I>hIMC</I><B>,
</B>    <B>UINT  </B><I>uEscape</I><B>,
</B>    <B>LPVOID  </B><I>lpData</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle</DD>

<DT><I>uEscape</I></DT>

<DD>Specifies the escape function to be performed.</DD>

<DT><I>lpData</I></DT>

<DD>Points to the data required for the specified escape.</DD>
</DL>

<P>The <B>ImeEscape</B> function supports the following escape functions.</P>

<TABLE>

<TR VALIGN="top">
<TH align=left width=46%><I>uEscape</I></TH>
<TH align=left width=54%>Meaning</TH>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_QUERY _SUPPORT</TD>
<TD width=54%>Checks for implementation. If this escape is not implemented, the return value is zero.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_RESERVED_FIRST</TD>
<TD width=54%>Escape that is between IME_ESC_RESERVED_FIRST and IME_ESC_RESERVED_LAST is reserved by the system.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_RESERVED_LAST</TD>
<TD width=54%>Escape that is between IME_ESC_RESERVED_FIRST and IME_ESC_RESERVED_LAST is reserved by the system.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_PRIVATE_FIRST</TD>
<TD width=54%>Escape that is between IME_ESC_PRIVATE_FIRST and IME_ESC_PRIVATE_LAST is reserved for the IME. The IME can freely use these escape functions for its own purposes.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_PRIVATE_LAST</TD>
<TD width=54%>Escape that is between IME_ESC_PRIVATE_FIRST and IME_ESC_PRIVATE_LAST is reserved for the IME. The IME can freely use these escape functions for its own purposes. </TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_SEQUENCE_TO_<BR>
INTERNAL</TD>
<TD width=54%>Escape that is Chinese specific. An application that wants to run under all East Asian platforms should not use this. It is for the Chinese EUDC editor. The *(LPWORD)<I>lpData</I> is the sequence code, and the return value is the character code for this sequence code. Typically, the Chinese IME will encode its reading character codes into sequence 1 to <I>n</I>.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_GET_EUDC_<BR>
DICTIONARY</TD>
<TD width=54%>Escape that is Chinese specific. An application that wants to run under all East Asian platforms should not use this. It is for the Chinese EUDC editor. On return from the function, the (LPTSTR)<I>lpData</I> is filled with the full path file name of the EUDC dictionary. The size of this buffer pointed by <I>lpData</I> should be greater or egual to MAX_PATH * sizeof(TCHAR). Note: Windows 95/98 and Windows NT 4.0 EUDC editor expect IMEs just use the buffer up to 80*sizeof(TCHAR).  </TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_SET_EUDC_<BR>
DICTIONARY</TD>
<TD width=54%>Sets the EUDC dictionary file. On input, the lpData parameter is the pointer to a null-terminated string specifying the full path. For use by the Chinese EUDC editor; do not use in other applications.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_MAX_KEY</TD>
<TD width=54%>Escape that is Chinese specific. An application that wants to run under all East Asian platforms should not use this. It is for the Chinese EUDC editor. The return value is the maximum keystrokes for a EUDC character.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_IME_NAME</TD>
<TD width=54%>Escape that is Chinese specific. An application that wants to run under all East Asian platforms should not use this. It is for the Chinese EUDC editor. On return from the function, the (LPTSTR) is the IME name to be displayed on the EUDC editor. The size of this buffer pointed to by <I>lpData</I> should be greater or equal to 16 * sizeof(TCHAR).</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_SYNC_HOTKEY</TD>
<TD width=54%>Escape that is (Traditional) Chinese specific. An application that wants to run under all East Asian platforms should not use this. It is for synchronizing between different IMEs. The input parameter *(LPDWORD)<I>lpData</I> is the IME private hot key ID. If this ID is zero, this IME should check every private hot key ID it concerns.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_HANJA_MODE</TD>
<TD width=54%>Escape that is Korean specific. An application that wants to run under all East Asian platforms should not use this. It is for conversion from Hangeul to Hanja. The input parameter (LPSTR)<I>lpData</I> is filled with Hangeul characters that will be converted to Hanja and its null-terminated string. When an application wants to convert any Hangeul character to a Hanja character by using the same method as the Hanja conversion when the composition character is present, the application only needs to request this function. The IME will then set itself as the Hanja conversion mode.</TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_GETHELPFILENAME</TD>
<TD width=54%>Escape that is the name of the IME’s help file. On return from the function, the (LPTSTR)<I>lpData</I> is the full path file name of the IME’s help file. The path name should be less than MAX_PATH * sizeof(TCHAR). This is added to Windows 98 and Windows 2000. Note: Windows 98 expects the path length is less than 80 TCHARs. </TD>
</TR>

<TR VALIGN="top">
<TD width=46%>IME_ESC_PRIVATE_HOTKEY</TD>
<TD width=54%><I>lpdata</I> points to a DWORD that contains the hot key ID (in the range of IME_HOTKEY_PRIVATE_FIRST and IME_HOTKEY_PRIVATE_LAST). After the system receives the hot key request within this range, the IMM will dispatch it to the IME using the <B>ImeEscape</B> function. Note: Windows® 95 does not support this escape.</TD>
</TR>
</TABLE><BR>

<H4>Return Values</H4>

<P>If the function fails, the return value is zero. Otherwise, the return value depends on each escape function.</P>

<H4>Comments</H4>

<P>Parameter validation should be inside each escape function for robustness.</P>

<P>When <I>uEscape</I> is IME_ESC_QUERY _SUPPORT, <I>lpData</I> is the pointer to the variable that contains the IME escape value. Following is an example that can be used to determine if the current IME supports IME_ESC_GETHELPFILENAME.</P>

<P>DWORD dwEsc = IME_ESC_GETHELPFILENAME;</P>

<P>LRESULT lRet = ImmEscape(hKL, hIMC, IME_ESC_QUERYSUPPORT, (LPVOID)&amp;dwEsc);</P>

<H4>See Also</H4>

<P><B>ImmEscape</B></P>

<H1>ImeSetActiveContext</H1>

<P>The <B>ImeSetActiveContext</B> function notifies the current IME active Input Context.</P>

<PRE class=syntax><B>BOOL
</B>  <B>ImeSetActiveContext(
</B>    <B>HIMC  </B><I>hIMC</I><B>,
</B>    <B>BOOL  </B><I>fFlag</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle.</DD>

<DT><I>fFlag</I></DT>

<DD>Two flags are provided. TRUE indicates activated and FALSE indicates deactivated. 
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H4>Comments</H4>

<P>The IME is informed by this function about a newly selected Input Context. The IME can carry out initialization, but it is not required.</P>

<H4>See Also</H4>

<P><B>ImeSetActiveContext</B></P>

<H1>ImeProcessKey</H1>

<P>The <B>ImeProcessKey</B> function preprocesses all the keystrokes given through the IMM and returns TRUE if that key is necessary for the IME with a given Input Context.</P>

<PRE class=syntax><B>BOOL
</B>  <B>ImeProcessKey(
</B>    <B>HIMC  </B><I>hIMC</I><B>,
</B>    <B>UINT  </B><I>uVirKey</I><B>,
</B>    <B>DWORD  </B><I>lParam</I><B>,
</B>    <B>CONST LPBYTE  </B><I>lpbKeyState</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle</DD>

<DT><I>uVirKey</I></DT>

<DD>Virtual key to be processed.</DD>

<DT><I>lParam</I></DT>

<DD><I>lParam</I> of key messages.</DD>

<DT><I>lpbKeyState</I></DT>

<DD>Points to a 256-byte array that contains the current keyboard state. The IME should not modify the content of the key state.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H4>Comments</H4>

<P>The system decides whether the key is handled by IME or not by calling this function. If the function returns TRUE before the application gets the key message, the IME will handle the key. The system will then call the <B>ImeToAsciiEx</B> function. If this function returns FALSE, the system recognizes that the key will not be handled by the IME and the key message will be sent to the application.</P>

<P>For IMEs that support IME_PROP_ACCEPT_WIDE_VKEY on Windows 2000, ImeProcessKey will receive full 32 bit value for uVirKey, which is injected by using SendInput API through VK_PACKET. uVirKey will include 16-bit Unicode in hiword even the IME may be ANSI version. </P>

<P>For IMEs that do not support IME_PROP_ACCEPT_WIDE_VKEY, Unicode IME's ImeProcessKey will receive VK_PACKET with zero'ed hiword. Unicode IME still can return TRUE so ImeToAsciiEx will be called with the injected Unicode. ANSI IME's ImeProcessKey will not receive anything. The injected Unicode will be discarded if the ANSI IME is open. If the ANSI IME is closed, the injected Unicode message will be posted to application's queue immediately.</P>

<H1>NotifyIME</H1>

<P>The <B>NotifyIME</B> function changes the status of the IME according to the given parameters.</P>

<PRE class=syntax><B>BOOL
</B>  <B>NotifyIME(
</B>    <B>HIMC  </B><I>hIMC</I><B>,
</B>    <B>DWORD  </B><I>dwAction</I><B>,
</B>    <B>DWORD  </B><I>dwIndex</I><B>,
</B>    <B>DWORD  </B><I>dwValue</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle.</DD>

<DT><I>dwAction</I></DT>

<DD>Following are the context items that an application can specify in the <I>dwAction</I> parameter.

<TABLE>

<TR VALIGN="top">
<TH align=left colspan=2 width=46%>Context Item</TH>
<TH align=left width=54%>Description</TH>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_OPENCANDIDATE </TD>
<TD width=54%>Application has the IME open the candidate list. If the IME opens the candidate list, the IME sends a <B>WM_IME_NOTIFY </B>(subfunction is IMN_OPENCANDIDATE) message.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>Index of the candidate list to be opened.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%>Not used.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_CLOSECANDIDATE</TD>
<TD width=54%>Application has the IME close the candidate list. If the IME closes the candidate list, the IME sends a <B>WM_IME_NOTIFY</B> (subfunction is IMN_CLOSECANDIDATE) message.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>Index of the candidate list to be closed.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%>Not used.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_SELECTCANDIDATESTR</TD>
<TD width=54%>Application selects one of the candidates.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>Index of the candidate list to be selected.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%>Index of the candidate string in the selected candidate list.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_CHANGECANDIDATELIST</TD>
<TD width=54%>Application changes the currently selected candidate.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>Index of the candidate list to be selected.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%>Not used.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_SETCANDIDATE_PAGESTART</TD>
<TD width=54%>Application changes the page starting index of the candidate list.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>Index of the candidate list to be changed.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%>New page start index.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_SETCANDIDATE_PAGESIZE</TD>
<TD width=54%>Application changes the page size of the candidate list.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>Index of the candidate list to be changed.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%>New page size.</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_CONTEXTUPDATED</TD>
<TD width=54%>Application or system updates the Input Context.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>When the value of <I>dwValue</I> is IMC_SETCONVERSIONMODE, <I>dwIndex</I> is the previous conversion mode.
<P>When the value of <I>dwValue</I> is IMC_SETSENTENCEMODE, <I>dwIndex</I> is the previous sentence mode.</P>

<P>For any other <I>dwValue, dwIndex</I> is not used.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%><I>O</I>ne of following values used by the <B>WM_IME_CONTROL</B> message:
<P>IMC_SETCANDIDATEPOS</P>

<P>IMC_SETCOMPOSITIONFONT</P>

<P>IMC_SETCOMPOSITIONWINDOW</P>

<P>IMC_SETCONVERSIONMODE</P>

<P>IMC_SETSENTENCEMODE</P>

<P>IMC_SETOPENSTATUS</P>
</TD>
</TR>

<TR VALIGN="top">
<TD colspan=2 width=46%>NI_COMPOSITIONSTR</TD>
<TD width=54%>Application changes the composition string. This action takes effect only when there is a composition string in the Input Context.</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwIndex</I></TD>
<TD width=54%>The following values are provided for <I>dwIndex:</I>
<P>CPS_COMPLETE</P>

<P>To determine the composition string as the result string.</P>

<P>CPS_CONVERT</P>

<P>To convert the composition string.</P>

<P>CPS_REVERT</P>

<P>To revert the composition string. The current composition string will be canceled and the unconverted string will be set as the composition string.</P>

<P>CPS_CANCEL </P>

<P>To clear the composition string and set the status as no composition string.</P>
</TD>
</TR>

<TR VALIGN="top">
<TD width=23%>&nbsp;</TD>
<TD width=23%><I>dwValue</I></TD>
<TD width=54%>Not used.</TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>dwIndex</I></DT>

<DD>Dependent on <I>uAction</I>.</DD>

<DT><I>dwValue</I></DT>

<DD>Dependent on <I>uAction</I>.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H4>See Also</H4>

<P><B>ImmNotifyIME</B></P>

<H1>ImeSelect</H1>

<P>The <B>ImeSelect</B> function is used to initialize and uninitialize the IME private context.</P>

<PRE class=syntax><B>BOOL
</B>  <B>ImeSelect(
</B>    <B>HIMC  </B><I>hIMC<B>,
</B></I>    <B>BOOL  </B><I>fSelect<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle</DD>

<DT><I>fSelect</I></DT>

<DD>Two flags are provided. TRUE indicates initialize and FALSE indicates uninitialize (free resource). 
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H1>ImeSetCompositionString</H1>

<P>The <B>ImeSetCompositionString</B> function is used by an application to set the IME composition string structure with the data contained in the <I>lpComp</I> or <I>lpRead</I> parameters. The IME then generates a <B>WM_IME_COMPOSITION</B> message.</P>

<PRE class=syntax><B>BOOL WINAPI
</B>  <B>ImeSetCompositionString(
</B>    <B>HIMC  </B><I>hIMC</I><B>,
</B>    <B>DWORD  </B><I>dwIndex</I><B>,
</B>    <B>LPCVOID  </B><I>lpComp</I><B>,
</B>    <B>DWORD  </B><I>dwCompLen</I><B>,
</B>    <B>LPCVOID  </B><I>lpRead</I><B>,
</B>    <B>DWORD  </B><I>dwReadLen</I><B>
</B>    <B>);</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>Input context handle. </DD>

<DT><I>dwIndex</I></DT>

<DD>The following values are provided for <I>dwIndex.</I>

<TABLE>

<TR VALIGN="top">
<TH align=left width=49%>Value</TH>
<TH align=left width=51%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=49%>SCS_SETSTR</TD>
<TD width=51%>Application sets the composition string, the reading string, or both. At least one of the <I>lpComp</I> and <I>lpRead</I> parameters must point to a valid string. If either string is too long, the IME truncates it.</TD>
</TR>

<TR VALIGN="top">
<TD width=49%>SCS_CHANGEATTR</TD>
<TD width=51%>Application sets attributes for the composition string, the reading string, or both. At least one of the <I>lpComp</I> and <I>lpRead</I> parameters must point to a valid attribute array. </TD>
</TR>

<TR VALIGN="top">
<TD width=49%>SCS_CHANGECLAUSE</TD>
<TD width=51%>Application sets the clause information for the composition string, the reading string, or both. At least one of the <I>lpComp</I> and <I>lpRead</I> parameters must point to a valid clause information array.</TD>
</TR>

<TR VALIGN="top">
<TD width=49%>SCS_QUERYRECONVERTSTRING</TD>
<TD width=51%>Application asks the IME to adjust its <B>RECONERTSTRINGSTRUCTRE</B>. If the application calls the <B>ImeSetCompositionString</B> function with this value, the IME adjusts the <B>RECONVERTSTRING</B> structure. The application can then pass the adjusted <B>RECONVERTSTRING</B> structure to this function with SCS_RECONVERTSTRING. The IME will not generate any <B>WM_IMECOMPOSITION</B> messages.</TD>
</TR>

<TR VALIGN="top">
<TD width=49%>SCS_SETRECONVERTSTRING</TD>
<TD width=51%>Application asks the IME to reconvert the string contained in the<B> RECONVERTSTRING</B> structure.</TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>lpComp</I></DT>

<DD>Pointer to the buffer that contains the updated string. The type of string is determined by the value of <I>dwIndex</I>.</DD>

<DT><I>dwCompLen</I></DT>

<DD>Length of the buffer in bytes.</DD>

<DT><I>lpRead</I></DT>

<DD>Pointer to the buffer that contains the updated string. The type of string is determined by the value of <I>dwIndex</I>. If the value of <I>dwIndex</I> is SCS_SETRRECONVERTSTRING or SCS_QUERYRECONVERTSTRING, <I>lpRead</I> will be a pointer to the <B>RECONVERTSTRING</B> structure that contains the updated reading string. If the selected IME has the value SCS_CAP_MAKEREAD, this can be NULL.</DD>

<DT><I>dwReadLen</I></DT>

<DD>Length of the buffer in bytes.
</DD>
</DL>

<H4>Comments</H4>

<P>For Unicode, <I>dwCompLen</I> and <I>dwReadLen</I> specifies the length of the buffer in bytes, even if SCS_SETSTR is specified and the buffer contains a Unicode string. </P>

<P>SCS_SETRECONVERTSTRING or SCS_QUERYRECONVERTSTRING can be used only for IMEs that have an SCS_CAP_SETRECONVERTSTRING property. This property can be retrieved by using the <B>ImmGetProperty</B> function.</P>

<H1>ImeToAsciiEx </H1>

<P>The <B>ImeToAsciiEx</B> function generates a conversion result through the IME conversion engine according to the <I>hIMC</I> parameter.</P>

<PRE class=syntax><B>UINT
</B>  <B>ImeToAsciiEx(
</B>    <B>UINT  </B><I>uVirKey</I><B>,
</B>    <B>UINT  </B><I>uScanCode</I><B>,
</B>    <B>CONST LPBYTE  </B><I>lpbKeyState</I><B>,
</B>    <B>LPTRANSMSGLIST  </B><I>lpTransMsgList</I><B>,
</B>    <B>UINT  </B><I>fuState</I><B>,
</B>    <B>HIMC  </B><I>hIMC</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>uVirKey</I></DT>

<DD>Specifies the virtual key code to be translated. When the property bit IME_PROP_KBD_CHAR_FIRST is on, the upper byte of the virtual key is the aid character code.

<P>For Unicode, the upper word of <I>uVirKey</I> contains the Unicode character code if the IME_PROP_KBD_CHAR_FIRST bit is on.
</DD>

<DT><I>uScanCode</I></DT>

<DD>Specifies the hardware scan code of the key to be translated.</DD>

<DT><I>LpbKeyState&nbsp;&nbsp;&nbsp;&nbsp;</I></DT>

<DD>Points to a 256-byte array that contains the current keyboard state. The IME should not modify the content of the key state.</DD>

<DT><I>lpTransMsgList</I></DT>

<DD>Point to a TRANSMSGLIST buffer to receive the translated message result. This was defined as a double word buffer in Windows 95/98 and Windows NT 4.0 IME document, and the double word buffer format is [Length of the pass in translated message buffer] [Message1] [wParam1] [lParam1] {[Message2] [wParam2] [lParam2]{...{...{...}}}}.</DD>

<DT><I>fuState</I></DT>

<DD>Active menu flag.</DD>

<DT><I>hIMC</I></DT>

<DD>Input context handle.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value indicates the number of messages. If the number is greater than the length of the translated message buffer, the translated message buffer is not enough. The system then checks <I>hMsgBuf</I> to get the translation messages.</P>

<H4>Comments</H4>

<P>On Windows 2000, a new 32bit-width virtual key code, using VK_PACKET in LOBYTE of wParam and the high word is Unicode, can be injected by using SendInput. </P>

<P>For ANSI IMEs that support IME_PROP_ACCEPT_WIDE_VKEY,<B> </B>ImeToAsciiEx may receive up to 16bit ANSI code for a character. It will be packed as below.  The character is injected from SendInput API through VK_PACKET. </P>

<TABLE border=1 frame=box rules=all>

<TR VALIGN="top">
<TD width=19%>24-31 bit</TD>
<TD width=31%>16-23 bit</TD>
<TD width=28%>8-15 bit</TD>
<TD width=22%>0-7 biy</TD>
</TR>

<TR VALIGN="top">
<TD width=19%>Reserved</TD>
<TD width=31%>Trailing DBCS byte(if any)</TD>
<TD width=28%>Leading byte</TD>
<TD width=22%>VK_PACKET</TD>
</TR>
</TABLE><BR>

<H4>See Also</H4>

<P><B>ImmToAsciiEx</B></P>

<H1>ImeRegisterWord</H1>

<P>The <B>ImeRegisterWord</B> function registers a string into the dictionary of this IME.</P>

<PRE class=syntax><B>BOOL WINAPI
</B>  <B>ImeRegisterWord(
</B>    <B>LPCTSTR  </B><I>lpszReading</I><B>,
</B>    <B>DWORD  </B><I>dwStyle</I><B>,
</B>    <B>LPCTSTR  </B><I>lpszString</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpszReading</I></DT>

<DD>Reading string of the registered string.</DD>

<DT><I>dwStyle</I></DT>

<DD>Style of the registered string. The following values are provided.

<TABLE>

<TR VALIGN="top">
<TH align=left width=48%>Value</TH>
<TH align=left width=52%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=48%>IME_REGWORD_STYLE_EUDC</TD>
<TD width=52%>String is within the EUDC range</TD>
</TR>

<TR VALIGN="top">
<TD width=48%>IME_REGWORD_STYLE_USER_FIRST to IME_REGWORD_STYLE_USER_LAST</TD>
<TD width=52%>Constants range from IME_REGWORD_STYLE_USER_FIRST to IME_REGWORD_STYLE_USER_LAST and are used for private styles of the IME ISV. The IME ISV can freely define its own style. For example:
<P>#define MSIME_NOUN (IME_REGWORD_STYLE_USER_FIRST)</P>

<P>#define MSIME_VERB (IME_REGWORD_STYLE_USER_FISRT +1)</P>
</TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>lpszString</I></DT>

<DD>String to be registered.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H1>ImeUnregisterWord</H1>

<P>The <B>ImeUnregisterWord</B> function removes a registered string from the dictionary of this IME.</P>

<PRE class=syntax><B>BOOL WINAPI
</B>  <B>ImeUnregisterWord(
</B>    <B>LPCTSTR  </B><I>lpszReading</I><B>,
</B>    <B>DWORD  </B><I>dwStyle</I><B>,
</B>    <B>LPCTSTR  </B><I>lpszString</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>lpszReading</I></DT>

<DD>Reading string of the registered string.</DD>

<DT><I>dwStyle</I></DT>

<DD>Style of the registered string. Please refer to the <B>ImeRegisterWord</B> function for a description of <I>dwStyle</I>. </DD>

<DT><I>lpszString</I></DT>

<DD>String to be unregistered.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is TRUE. Otherwise, the return value is FALSE.</P>

<H1>ImeGetRegisterWordStyle</H1>

<P>The <B>ImeGetRegisterWordStyle</B> function gets the available styles in this IME.</P>

<PRE class=syntax><B>UINT WINAPI
</B>  <B>ImeGetRegisterWordStyle(
</B>    <B>UINT  </B><I>nItem<B>,
</B></I>    <B>LPSTYLEBUF  </B><I>lpStyleBuf<B>
</B></I>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>nItem</I></DT>

<DD>Maximum number of styles that the buffer can hold.</DD>

<DT><I>lpStyleBuf</I></DT>

<DD>Buffer to be filled.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value is the number of the styles copied to the buffer. If <I>nItems</I> is zero, the return value is the buffer size in array elements needed to receive all available styles in this IME.</P>

<H1>ImeEnumRegisterWord</H1>

<P>The <B>ImeEnumRegisterWord</B> function enumerates the information of the registered strings with specified reading string, style, and registered string data.</P>

<PRE class=syntax><B>UINT WINAPI
</B>  <B>ImeEnumRegisterWord(
</B>    <B>hKL</B>  <I>hKL</I><B>,
</B>    <B>REGISTERWORDENUMPROC  </B><I>lpfnEnumProc</I><B>,
</B>    <B>LPCTSTR  </B><I>lpszReading</I><B>,
</B>    <B>DWORD  </B><I>dwStyle</I><B>,
</B>    <B>LPCTSTR  </B><I>lpszString</I><B>,
</B>    <B>LPVOID  </B><I>lpData</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hKL</I></DT>

<DD>Input language handle.</DD>

<DT><I>lpfnEnumProc</I></DT>

<DD>Address of callback function.</DD>

<DT><I>lpszReading</I></DT>

<DD>Specifies the reading string to be enumerated. If <I>lpszReading </I>is NULL, <B>ImeEnumRegisterWord</B> enumerates all available reading strings that match the specified <I>dwStyle</I> and <I>lpszString</I> parameters.</DD>

<DT><I>dwStyle</I></DT>

<DD>Specifies the style to be enumerated. If <I>dwStyle</I> is NULL, <B>ImeEnumRegisterWord</B> enumerates all available styles that match the specified <I>lpszReading </I>and <I>lpszString</I> parameters.</DD>

<DT><I>lpszString</I></DT>

<DD>Specifies the registered string to be enumerated. If <I>lpszString</I> is NULL, <B>ImeEnumRegisterWord</B> enumerates all registered strings that match the specified <I>lpszReading </I>and <I>dwStyle</I> parameters.</DD>

<DT><I>lpData</I></DT>

<DD>Address of application-supplied data.
</DD>
</DL>

<H4>Return Values</H4>

<P>If the function is successful, the return value is the last value returned by the callback function. Its meaning is defined by the application.</P>

<H4>Comments</H4>

<P>If all <I>lpszReading dwStyle</I>, and <I>lpszString</I> parameters are NULL, <B>ImeEnumRegisterWord</B> enumerates all registered strings in the IME dictionary. If any two of the input parameters are NULL, <B>ImeEnumRegisterWord</B> enumerates all registered strings matching the third parameter.</P>

<H1>ImeGetImeMenuItems</H1>

<P>The <B>ImeGetImeMenuItems</B> function gets the menu items that are registered in the IME menu.</P>

<PRE class=syntax><B>DWORD WINAPI
</B>  <B>ImeGetImeMenuItems(
</B>    <B>HIMC  </B><I>hIMC</I><B>,
</B>    <B>DWORD  </B><I>dwFlags</I><B>,
</B>    <B>DWORD  </B><I>dwType</I><B>,
</B>    <B>LPIMEMENUITEMINFO  </B><I>lpImeParentMenu</I><B>,
</B>    <B>LPIMEMENUITEMINFO  </B><I>lpImeMenu</I><B>,
</B>    <B>DWORD  </B><I>dwSize</I><B>
</B>    <B>)</B></PRE>

<H4>Parameters</H4>

<DL>
<DT><I>hIMC</I></DT>

<DD>The <I>lpMenuItem</I> contains menu items that are related to this input context.</DD>

<DT><I>dwFlags</I></DT>

<DD>Consists of the following bit combinations.

<TABLE>

<TR VALIGN="top">
<TH align=left width=37%>Bit</TH>
<TH align=left width=63%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMIF_RIGHTMENU</TD>
<TD width=63%>If this bit is 1, this function returns the menu items for the right click Context menu.</TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>dwType</I></DT>

<DD>Consists of the following bit combinations.

<TABLE>

<TR VALIGN="top">
<TH align=left width=37%>Bit</TH>
<TH align=left width=63%>Description</TH>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMII_CMODE</TD>
<TD width=63%>Returns the menu items related to the conversion mode.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMII_SMODE</TD>
<TD width=63%>Returns the menu items related to the sentence mode.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMII_CONFIGURE</TD>
<TD width=63%>Returns the menu items related to the configuration of IME.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMII_TOOLS</TD>
<TD width=63%>Returns the menu items related to the IME tools.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMII_HELP</TD>
<TD width=63%>Returns the menu items related to IME help.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMII_OTHER</TD>
<TD width=63%>Returns the menu items related to others.</TD>
</TR>

<TR VALIGN="top">
<TD width=37%>IGIMII_INPUTTOOLS</TD>
<TD width=63%>Returns the menu items related to the IME input tools that provide the extended way to input the characters.</TD>
</TR>
</TABLE><BR>

</DD>

<DT><I>lpImeParentMenu</I></DT>

<DD>Pointer to the <B>IMEMENUINFO</B> structure that has MFT_SUBMENU in <I>fType</I>. <B>ImeGetImeMenuItems</B> returns the submenu items of this menu item. If this is NULL, <I>lpImeMenu</I> contains the top-level IME menu items.</DD>

<DT><I>lpImeMenu</I></DT>

<DD>Pointer to the buffer to receive the contents of the menu items. This buffer is the array of <B>IMEMENUITEMINFO</B> structure. If this is NULL, <B>ImeGetImeMenuItems</B> returns the number of the registered menu items.</DD>

<DT><I>dwSize</I></DT>

<DD>Size of the buffer to receive the <B>IMEMENUITEMINFO</B> structure.
</DD>
</DL>

<H4>Return Values</H4>

<P>The return value is the number of the menu items that were set into <I>lpIM</I>. If <I>lpImeMenu</I> is NULL, <B>ImeGetImeMenuItems</B> returns the number of menu items that are registered in the specified <I>hKL</I>.</P>

<H4>Comments</H4>

<P><B>ImeGetImeMenuItems</B> is a new function for Windows 98 and Windows 2000.</P>

<P></P>
<DIV CLASS="footer"><A HREF="mailto:ddksurv1@microsoft.com?subject=DDK Topic Feedback&body=Build date: Thursday, January 16, 2003     Topic Title: Win32%20Multilingual%20IME%20Application%20Programming%20Interface"> Send feedback on this topic.</A> / Built on Thursday, January 16, 2003 </DIV>
</BODY>
</HTML>
