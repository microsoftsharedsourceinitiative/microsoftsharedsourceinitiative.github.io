<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML DIR="LTR"><HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Global Flag Reference</TITLE>
<SCRIPT SRC="../scripts/linkcss.js"></SCRIPT><SCRIPT SRC="../scripts/langref.js"></SCRIPT><META NAME="MS-HKWD" CONTENT="Global Flag Reference">
<META NAME="MS-HKWD" CONTENT="Buffer DbgPrint output">
<META NAME="MS-HKWD" CONTENT="Create kernel mode stack trace database">
<META NAME="MS-HKWD" CONTENT="Create user mode stack trace database">
<META NAME="MS-HKWD" CONTENT="Debug initial command">
<META NAME="MS-HKWD" CONTENT="Debug WinLogon">
<META NAME="MS-HKWD" CONTENT="Disable heap coalesce on free">
<META NAME="MS-HKWD" CONTENT="Disable paging of kernel stacks">
<META NAME="MS-HKWD" CONTENT="Disable protected DLL verification">
<META NAME="MS-HKWD" CONTENT="Disable stack extension">
<META NAME="MS-HKWD" CONTENT="Early critical section event creation">
<META NAME="MS-HKWD" CONTENT="Enable application verifier">
<META NAME="MS-HKWD" CONTENT="Enable bad handles detection">
<META NAME="MS-HKWD" CONTENT="Enable close exception">
<META NAME="MS-HKWD" CONTENT="Enable debugging of Win32 subsystem">
<META NAME="MS-HKWD" CONTENT="Enable exception logging">
<META NAME="MS-HKWD" CONTENT="Enable heap free checking">
<META NAME="MS-HKWD" CONTENT="Enable heap parameter checking">
<META NAME="MS-HKWD" CONTENT="Enable heap tagging">
<META NAME="MS-HKWD" CONTENT="Enable heap tagging by DLL">
<META NAME="MS-HKWD" CONTENT="Enable heap tail checking">
<META NAME="MS-HKWD" CONTENT="Enable heap validation on call">
<META NAME="MS-HKWD" CONTENT="Enable loading of kernel debugger symbols">
<META NAME="MS-HKWD" CONTENT="Enable object handle type tagging">
<META NAME="MS-HKWD" CONTENT="Enable page heap">
<META NAME="MS-HKWD" CONTENT="Enable pool tagging">
<META NAME="MS-HKWD" CONTENT="Enable system critical breaks">
<META NAME="MS-HKWD" CONTENT="Load DLLs top-down">
<META NAME="MS-HKWD" CONTENT="Maintain a list of objects for each type">
<META NAME="MS-HKWD" CONTENT="Show loader snaps">
<META NAME="MS-HKWD" CONTENT="Stop on exception">
<META NAME="MS-HKWD" CONTENT="Stop on hung GUI">
</HEAD>
<BODY TOPMARGIN="0">
<DIV STYLE="display:none;">
<OBJECT ID="hhobj_1" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="ddk_exallocatepoolwithtag_kr">
</OBJECT>
<OBJECT ID="hhobj_2" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="ddk_exallocatepoolwithquotatag_kr">
</OBJECT>
<OBJECT ID="hhobj_3" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="ddk_exallocatepool_kr">
</OBJECT>
<OBJECT ID="hhobj_4" TYPE="application/x-oleobject" CLASSID="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
	<PARAM NAME="Command" VALUE="ALink,MENU">
	<PARAM NAME="DefaultTopic" VALUE="../notopic_0pk4.htm">
	<PARAM NAME="Item1" VALUE="">
	<PARAM NAME="Item2" VALUE="ddk_exallocatepoolwithquota_kr">
</OBJECT>
</DIV>


<TABLE CLASS="buttonbarshade" CELLSPACING=0><TR><TD>&nbsp;</TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING=0>
<TR ID="hdr"><TD CLASS="runninghead" NOWRAP>Driver&nbsp;Development&nbsp;Tools:&nbsp;Windows&nbsp;DDK</TD></TR>
</TABLE>
<H2><A NAME="ddk_global_flag_reference_tools"></A>Global Flag Reference</H2>

<P>This reference describes the flags that Gflags sets in more detail.</P>

<P class=note><B>Note</B>&nbsp;&nbsp;The symbolic name of each flag is provided for reference only. Because symbolic names change, they are not a reliable identifier of a global flag. </P>



<H3><A NAME="ddk_buffer_dbgprint_output_tools"></A>Buffer DbgPrint Output</H3>

<P>The <B>Buffer DbgPrint Output</B> flag suppresses debugger output from <A HREF="debugfns_9ecz.htm"><B>DbgPrint</B></A>, <A HREF="debugfns_6x9v.htm"><B>DbgPrintEx</B></A>, <A HREF="debugfns_8odv.htm"><B>KdPrint</B></A>, and <A HREF="debugfns_1ier.htm"><B>KdPrintEx</B></A> calls.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>ddp</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x08000000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_DISABLE_DBGPRINT</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry, kernel mode</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>When debugger output is suppressed, it does not automatically appear in the kernel debugger. However, it can still be accessed by using the <B>!dbgprint</B> debugger extension.</P>

<P>For information on debugger extensions, see <A HREF="dbgblurb_25bn.htm">Debugging Tools for NT-Based Operating Systems</A>.</P>



<H3><A NAME="ddk_create_kernel_mode_stack_trace_database_tools"></A>Create kernel mode stack trace database</H3>

<P>The <B>Create kernel mode stack trace database</B> flag creates a run-time stack trace database of kernel operations, such as resource objects and object management operations, and works only when using the checked build of Windows.</P>

<TABLE>

<TR VALIGN="top">
<TD width=40%><B>Abbreviation</B></TD>
<TD width=60%>kst</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>Hexadecimal value</B></TD>
<TD width=60%>0x2000</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>Symbolic Name</B></TD>
<TD width=60%>FLG_KERNEL_STACK_TRACE_DB</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>Destination</B></TD>
<TD width=60%>System-wide registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>GFlags displays this flag as a kernel-mode setting, but it is not effective in kernel mode because the kernel is already started. </P>



<H3><A NAME="ddk_create_user_mode_stack_trace_database_tools"></A>Create user mode stack trace database</H3>

<P>The <B>Create user mode stack trace database</B> flag creates a run-time stack trace database in the address space of a particular process (image file mode) or all processes (system-wide).</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>ust</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x1000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_USER_STACK_TRACE_DB</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>



<H3><A NAME="ddk_debug_initial_command_tools"></A>Debug initial command</H3>

<P>The <B>Debug initial command</B> flag debugs the Client Server Run-time Subsystem (CSRSS) and the WinLogon process.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>dic</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x4</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_DEBUG_INITIAL_COMMAND</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>NTSD debugs the processes (using the command <B>ntsd -d</B>), but control is redirected to the kernel debugger.</P>

<P>See <A HREF="dbgblurb_25bn.htm">Debugging Tools for NT-Based Operating Systems</A> for more details.</P>

<P class=note><B>Note</B>&nbsp;&nbsp;GFlags displays this flag as a kernel-mode setting, but it is not effective in kernel mode because it cannot be set without rebooting Windows.</P>

<H4>See also</H4>

<P><A HREF="#ddk_debug_winlogon_tools">Debug WinLogon</A>, <A HREF="#ddk_enable_debugging_of_win32_subsystem_tools">Enable debugging of Win32 subsystem</A></P>



<H3><A NAME="ddk_debug_winlogon_tools"></A>Debug WinLogon</H3>

<P>The <B>Debug WinLogon</B> flag debugs the WinLogon service.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>dwl</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x04000000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_DEBUG_INITIAL_COMMAND_EX</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>NTSD debugs Winlogon (by using the command <B>ntsd -d -g -x</B>), but control is redirected to the kernel debugger.</P>

<P>For more details, see <A HREF="dbgblurb_25bn.htm">Debugging Tools for NT-Based Operating Systems</A>.</P>

<P class=note><B>Note</B>&nbsp;&nbsp;GFlags displays this flag as a kernel-mode setting, but it is not effective in kernel mode because it cannot be set without rebooting Windows.</P>

<H4>See Also</H4>

<P><A HREF="#ddk_debug_initial_command_tools">Debug Initial Command</A>, <A HREF="#ddk_enable_debugging_of_win32_subsystem_tools">Enable debugging of Win32 subsystem</A></P>



<H3><A NAME="ddk_disable_heap_coalesce_on_free_tools"></A>Disable heap coalesce on free</H3>

<P>The <B>Disable heap coalesce on free</B> flag leaves adjacent blocks of heap memory separate when they are freed. </P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>dhc</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x00200000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_DISABLE_COALESCING</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>By default, Windows combines ("coalesces") newly-freed adjacent blocks into a single block. Combining the blocks takes time, but reduces fragmentation that might force the heap to allocate additional memory when it cannot find contiguous memory.</P>

<P>This flag is used to test optimizing strategies. It is not used for debugging.</P>



<H3><A NAME="ddk_disable_paging_of_kernel_stacks_tools"></A>Disable paging of kernel stacks</H3>

<P>The <B>Disable paging of kernel stacks</B> flag prevents paging of the kernel-mode stacks of inactive threads. </P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>dps</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x80000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_DISABLE_PAGE_KERNEL_STACKS</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>Generally, the kernel-mode stack cannot be paged; it is guaranteed to be resident in memory. However, Windows occasionally pages the kernel stacks of inactive threads. This flag prevents these occurrences.</P>

<P>The kernel debugger can provide information about a thread only when its stack is in physical memory. This flag is particularly important when debugging deadlocks and in other cases when every thread must be tracked.</P>

<P class=note><B>Note</B>&nbsp;&nbsp;GFlags displays this flag as a kernel mode setting, but it is not effective in kernel mode because it cannot be set without rebooting Windows.</P>



<H3><A NAME="ddk_disable_protected_dll_verification_tools"></A>Disable protected DLL verification</H3>

<P>The <B>Disable protected DLL verification</B> flag appears in GFlags, but it has no effect on Windows.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>dpd</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x80000000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_DISABLE_PROTDLLS</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>



<H3><A NAME="ddk_disable_stack_extension_tools"></A>Disable stack extension</H3>

<P>The <B>Disable stack extension</B> flag prevents the kernel from extending the stacks of the threads in the process beyond the initial committed memory.</P>

<TABLE>

<TR VALIGN="top">
<TD width=38%><B>Abbreviation</B></TD>
<TD width=62%>dse</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>Hexadecimal value</B></TD>
<TD width=62%>0x10000</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>Symbolic Name</B></TD>
<TD width=62%>FLG_DISABLE_STACK_EXTENSION</TD>
</TR>

<TR VALIGN="top">
<TD width=38%><B>Destination</B></TD>
<TD width=62%>Image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>This feature is used to simulate low memory conditions (where stack extensions fail) and to test the strategic system processes that are expected to run well even with low memory.</P>



<H3><A NAME="ddk_early_critical_section_event_creation_tools"></A>Early critical section event creation</H3>

<P>The <B>Early critical section event creation</B> flag creates event handles when a critical section is initialized, rather than waiting until the event is needed. </P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>cse</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x10000000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_CRITSEC_EVENT_CREATION</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>When Windows cannot create an event, it generates the exception during initialization and the calls to enter and leave the critical section do not fail.</P>

<P>Because this flag uses a significant amount of nonpaged pool memory, use it only on very reliable systems that have sufficient memory.</P>



<H3><A NAME="ddk_enable_application_verifier_tools"></A>Enable application verifier</H3>

<P>The <B>Enable application verifier</B> flag enables system features that are used for user-mode application testing, such as page heap verification, lock checks, and handle checks. </P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>vrf</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x100</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_APPLICATION_VERIFIER</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>This flag enables only the most basic detection features. To test user-mode applications reliably, use Application Verifier (<I>AppVerif.exe</I>), a tool included in the Windows Application Compatibility Toolkit. You can download the Application Compatibility Toolkit from the <a href="http://go.microsoft.com/fwlink/?linkid=11573&clcid=0x409" target="_blank">Windows Application and Customer Experience</A> Web site. Use this flag only when the Application Verifier is not available. </P>

<P>Despite its name, this flag does not enable or configure any features of the Application Verifier tool.</P>



<H3><A NAME="ddk_enable_bad_handles_detection_tools"></A>Enable bad handles detection</H3>

<P>The <B>Enable bad handles detection</B> flag raises a user-mode exception (STATUS_INVALID_HANDLE) whenever a user-mode process passes an invalid handle to the Object Manager.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>bhd</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x40000000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_ENABLE_HANDLE_EXCEPTIONS</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry, kernel mode</TD>
</TR>
</TABLE><BR>



<H3><A NAME="ddk_enable_close_exception_tools"></A>Enable close exception</H3>

<P>The <B>Enable close exception</B> flag raises a user-mode exception whenever an invalid handle is passed to the <B>CloseHandle</B> interface or related interfaces, such as <B>SetEvent</B>, that take handles as arguments.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>ece</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x00400000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_ENABLE_CLOSE_EXCEPTIONS</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry, kernel mode</TD>
</TR>
</TABLE><BR>

<P class=note><B>Note</B>&nbsp;&nbsp;This flag is still supported, but the <A HREF="#ddk_enable_bad_handles_detection_tools">Enable bad handles detection</A> flag (bhd), which performs a more comprehensive check of handle use, is preferred.</P>



<H3><A NAME="ddk_enable_debugging_of_win32_subsystem_tools"></A>Enable debugging of Win32 subsystem</H3>

<P>The <B>Enable debugging of Win32 subsystem</B> flag debugs the Client Server Run-time Subsystem (<I>csrss.exe</I>) in the NTSD debugger.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>d32</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x20000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_ENABLE_CSRDEBUG</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>NTSD debugs the process  by using the command <B>ntsd -d -p 1</B>.</P>

<P>This flag is effective only when the <A HREF="#ddk_debug_initial_command_tools">Debug Initial Command</A> flag (dic) or the <A HREF="#ddk_debug_winlogon_tools">Debug WinLogon</A> flag (dwl) is also set.</P>

<P>For details on NTSD, see <A HREF="dbgblurb_25bn.htm">Debugging Tools for NT-Based Operating Systems</A>. </P>

<P class=note><B>Note</B>&nbsp;&nbsp;GFlags displays this flag as a kernel-mode setting, but it is not effective in kernel mode because it cannot be set without rebooting Windows.</P>



<H3><A NAME="ddk_enable_exception_logging_tools"></A>Enable exception logging</H3>

<P>The <B>Enable exception logging</B> flag creates a log of exception records in the kernel run-time library. You can access the log from a kernel debugger.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>eel</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x00800000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_ENABLE_EXCEPTION_LOGGING</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry, kernel mode</TD>
</TR>
</TABLE><BR>



<H3><A NAME="ddk_enable_heap_free_checking_tools"></A>Enable heap free checking</H3>

<P>The <B>Enable heap free checking</B> flag validates each heap allocation when it is freed.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>hfc</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x20</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_ENABLE_FREE_CHECK</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>See Also</H4>

<P><A HREF="#ddk_enable_heap_tail_checking_tools">Enable heap tail checking</A>, <A HREF="#ddk_enable_heap_parameter_checking_tools">Enable heap parameter checking</A></P>



<H3><A NAME="ddk_enable_heap_parameter_checking_tools"></A>Enable heap parameter checking</H3>

<P>The <B>Enable heap parameter checking</B> flag verifies selected aspects of the heap whenever a heap function is called.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>hpc</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x40</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_VALIDATE_PARAMETERS</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>See Also</H4>

<P><A HREF="#ddk_enable_heap_validation_on_call_tools">Enable heap validation on call</A></P>



<H3><A NAME="ddk_enable_heap_tagging_tools"></A>Enable heap tagging</H3>

<P>The <B>Enable heap tagging</B> flag assigns unique tags to heap allocations.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>htg</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x800</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_ENABLE_TAGGING</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>You can display the tag by using the <B>!heap</B> debugger extension with the <B>-t</B> parameter.</P>

<P>For information about debugger extensions, see <A HREF="dbgblurb_25bn.htm">Debugging Tools for NT-Based Operating Systems</A>.</P>

<H4>See Also</H4>

<P><A HREF="#ddk_enable_heap_tagging_by_dll_tools">Enable heap tagging by DLL</A> </P>



<H3><A NAME="ddk_enable_heap_tagging_by_dll_tools"></A>Enable heap tagging by DLL</H3>

<P>The <B>Enable heap tagging by DLL</B> flag assigns a unique tag to heap allocations created by the same DLL.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>htd</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x8000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_ENABLE_TAG_BY_DLL</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>You can display the tag by using the <B>!heap</B> debugger extension with the -t parameter.</P>

<P>For information about debugger extensions, see <A HREF="dbgblurb_25bn.htm">Debugging Tools for NT-Based Operating Systems</A>.</P>

<H4>See Also</H4>

<P><A HREF="#ddk_enable_heap_tagging_tools">Enable heap tagging</A> </P>



<H3><A NAME="ddk_enable_heap_tail_checking_tools"></A>Enable heap tail checking</H3>

<P>The <B>Enable heap tail checking</B> flag checks for buffer overruns when the heap is freed.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>htc</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x10</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_ENABLE_TAIL_CHECK</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>This flag adds a short pattern to the end of each allocation. The Windows heap manager detects the pattern when the block is freed and, if the block was modified, the heap manager breaks into the debugger.</P>

<H4>See Also</H4>

<P><A HREF="#ddk_enable_heap_free_checking_tools">Enable heap free checking</A>, <A HREF="#ddk_enable_heap_parameter_checking_tools">Enable heap parameter checking</A> </P>



<H3><A NAME="ddk_enable_heap_validation_on_call_tools"></A>Enable heap validation on call</H3>

<P>The <B>Enable heap validation on call</B> flag validates the entire heap each time a heap function is called.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>hvc</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x80</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_VALIDATE_ALL</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>To avoid the high overhead associated with this flag, use the <B>HeapValidate</B> function instead of setting this flag, especially at critical junctures, such as when the heap is destroyed. However, this flag is useful for detecting random corruption in a pool.</P>

<H4>See Also</H4>

<P><A HREF="#ddk_enable_heap_parameter_checking_tools">Enable heap parameter checking</A> </P>



<H3><A NAME="ddk_enable_loading_of_kernel_debugger_symbols_tools"></A>Enable loading of kernel debugger symbols</H3>

<P>The <B>Enable loading of kernel debugger symbols</B> flag loads kernel symbols into the kernel memory space the next time Windows starts.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>ksl</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x40000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_ENABLE_KDEBUG_SYMBOL_LOAD</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry, kernel mode</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>The kernel symbols are used in kernel profiling and by advanced kernel debugging tools.</P>



<H3><A NAME="ddk_enable_object_handle_type_tagging_tools"></A>Enable object handle type tagging</H3>

<P>The <B>Enable object handle type tagging </B>flag appears in GFlags, but it has no effect on Windows.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>eot</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x01000000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_ENABLE_HANDLE_TYPE_TAGGING</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry, kernel mode</TD>
</TR>
</TABLE><BR>



<H3><A NAME="ddk_enable_page_heap_tools"></A>Enable page heap</H3>

<P>The <B>Enable page heap</B> flag turns on page heap verification, which monitors dynamic heap memory operations, including allocate and free operations, and causes a debugger break when the verifier detects a heap error.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>hpa</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x02000000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_HEAP_PAGE_ALLOCS</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>This option enables full page heap verification when set for image files and standard page heap verification when set in system registry or kernel mode.

<UL>
	<LI><I>Full page heap verification</I> (for <B>/i</B>) places a zone of reserved virtual memory at the end of each allocation. </LI>

	<LI><I>Standard page heap verification</I> (for <B>/r</B> or <B>/k</B>) places random patterns at the end of an allocation and examines the patterns when a heap block is freed. </LI>
</UL>

<P>Setting this flag for an image file is the same as typing <B>gflags /p enable <I>ImageFile</I> /full</B> for the image file at the command line.</P>



<H3><A NAME="ddk_enable_pool_tagging_tools"></A>Enable pool tagging</H3>

<P>The <B>Enable pool tagging</B> flag collects data and calculates statistics about pool memory allocations sorted by pool tag value.</P>

<TABLE>

<TR VALIGN="top">
<TD width=40%><B>Abbreviation</B></TD>
<TD width=60%>ptg</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>Hexadecimal value</B></TD>
<TD width=60%>0x400</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>Symbolic Name</B></TD>
<TD width=60%>FLG_POOL_ENABLE_TAGGING</TD>
</TR>

<TR VALIGN="top">
<TD width=40%><B>Destination</B></TD>
<TD width=60%>System-wide registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>This flag is permanently set in Windows Server&nbsp;2003 and later versions of Windows. On these systems, the <B>Enable pool tagging</B> checkbox in the Global Flags dialog box is dimmed and commands to enable or disable pool tagging fail. </P>

<P>Use <A HREF="JavaScript:hhobj_1.Click()"><B>ExAllocatePoolWithTag</B></A> or <A HREF="JavaScript:hhobj_2.Click()"><B>ExAllocatePoolWithQuotaTag</B></A> to set the tag value. When no tag value is specified (<A HREF="JavaScript:hhobj_3.Click()"><B>ExAllocatePool</B></A>, <A HREF="JavaScript:hhobj_4.Click()"><B>ExAllocatePoolWithQuota</B></A>), Windows creates a tag with the default value of "None." Because data for all allocations with a "None" tag is combined, you cannot distinguish the data for a specific allocation.</P>

<P>In Windows XP and earlier systems, this flag also directs Windows to attach a pool tag even when the pool memory is allocated by using <B>ExAllocatePoolWithQuotaTag</B>. Otherwise, the tag bytes are used to store the quota values. In Windows Server&nbsp;2003, tag values and quota values are stored in separate fields that are attached to every pool memory allocation.</P>

<P class=note><B>Note</B>&nbsp;&nbsp;To display the data that Windows collects about a tagged allocation, use the <A HREF="poolmon_7983.htm">PoolMon</A>.</P>

<P class=note>The description of the <B>Enable Pool Tagging</B> flag in the Windows XP Support Tools documentation is incomplete. This flag directs Windows to collect and process data by tag value.</P>



<H3><A NAME="ddk_enable_system_critical_breaks_tools"></A>Enable system critical breaks</H3>

<P>The <B>Enable system critical breaks</B> flag forces a system break into the debugger.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>scb</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x100000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_ENABLE_SYSTEM_CRIT_BREAKS</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>For per-process (image file), this flag forces a system break into the debugger whenever the specified process stops abnormally. This flag is effective only when the process calls the <B>RtlSetProcessBreakOnExit</B> and <B>RtlSetThreadBreakOnExit</B> interfaces. </P>

<P>For system-wide (registry or kernel mode), this flag forces a system break into the debugger whenever processes that have called the <B>RtlSetProcessBreakOnExit</B> and <B>RtlSetThreadBreakOnExit</B> interfaces stop abnormally. </P>



<H3><A NAME="ddk_load_dlls_top_down_tools"></A>Load DLLs top-down</H3>

<P>The <B>Load DLLs top-down</B> flag loads DLLs at the highest possible address. </P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>ltd</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x20000000</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_LDR_TOP_DOWN</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>This flag is used to test 64-bit code for pointer truncation errors, because the most significant 32 bits of the pointers are not zeroes. It is designed for code running on the 64-bit versions of Windows Server&nbsp;2003 and later versions of Windows.</P>



<H3><A NAME="ddk_maintain_a_list_of_objects_for_each_type_tools"></A>Maintain a list of objects for each type</H3>

<P>The <B>Maintain a list of objects for each type</B> flag collects and maintains a list of active objects by object type, for example, event, mutex, and semaphore.</P>

<TABLE>

<TR VALIGN="top">
<TD width=30%><B>Abbreviation</B></TD>
<TD width=70%>otl</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Hexadecimal value</B></TD>
<TD width=70%>0x4000</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Symbolic Name</B></TD>
<TD width=70%>FLG_MAINTAIN_OBJECT_TYPELIST</TD>
</TR>

<TR VALIGN="top">
<TD width=30%><B>Destination</B></TD>
<TD width=70%>System-wide registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>To display the object list, use Open Handles (<I>oh.exe</I>), a tool included in the Windows&nbsp;2000 Resource Kit, and now available for download from the <a href="http://go.microsoft.com/fwlink/?linkid=11233&clcid=0x409" target="_blank">Microsoft Windows 2000 Resource Kit</A> Web site. Because Open Handles automatically sets the OTL flag, but does not clear it, use <B>GFlags -otl</B> to clear the flag.</P>

<P class=note><B>Note</B>&nbsp;&nbsp;The linked lists created when you set this flag use eight bytes of overhead for each object. Remember to clear this flag when your analysis is complete. </P>

<P class=note>This flag is available as a kernel-mode setting, but it is not effective in kernel mode because the kernel is already started. </P>



<H3><A NAME="ddk_show_loader_snaps_tools"></A>Show loader snaps</H3>

<P>The <B>Show loader snaps</B> flag captures detailed information about the loading and unloading of executable images and their supporting library modules and displays the data in the kernel debugger console.</P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>sls</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x2</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_SHOW_LDR_SNAPS</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>For system-wide (registry or kernel mode), this flag displays information about driver loading and unloading operations.</P>

<P>For per-process (image file), this flag displays information about loading and unloading of DLLs.</P>



<H3><A NAME="ddk_stop_on_exception_tools"></A>Stop on exception</H3>

<P>The <B>Stop on exception</B> flag causes the kernel to break into the kernel debugger whenever a kernel-mode exception occurs. </P>

<TABLE>

<TR VALIGN="top">
<TD width=21%><B>Abbreviation</B></TD>
<TD width=79%>soe</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Hexadecimal value</B></TD>
<TD width=79%>0x1</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Symbolic Name</B></TD>
<TD width=79%>FLG_STOP_ON_EXCEPTION</TD>
</TR>

<TR VALIGN="top">
<TD width=21%><B>Destination</B></TD>
<TD width=79%>System-wide registry entry, kernel mode, image file registry entry</TD>
</TR>
</TABLE><BR>

<H4>Comments</H4>

<P>Windows passes all first chance exceptions (except for STATUS_PORT_DISCONNECT) with a severity of Warning or Error to the debugger before passing them to a local exception handler.</P>



<H3><A NAME="ddk_stop_on_hung_gui_tools"></A>Stop on hung GUI</H3>

<P>The <B>Stop on hung GUI</B> flag appears in GFlags, but it has no effect on Windows.</P>

<TABLE>

<TR VALIGN="top">
<TD width=45%><B>Abbreviation</B></TD>
<TD width=55%>shg</TD>
</TR>

<TR VALIGN="top">
<TD width=45%><B>Hexadecimal value</B></TD>
<TD width=55%>0x8</TD>
</TR>

<TR VALIGN="top">
<TD width=45%><B>Symbolic Name</B></TD>
<TD width=55%>FLG_STOP_ON_HUNG_GUI</TD>
</TR>

<TR VALIGN="top">
<TD width=45%><B>Destination</B></TD>
<TD width=55%>Kernel mode</TD>
</TR>
</TABLE><BR>

<P></P>
<DIV CLASS="footer"><A HREF="mailto:ddksurv1@microsoft.com?subject=DDK Topic Feedback&body=Build date: Thursday, January 16, 2003     Topic Title: Global%20Flag%20Reference"> Send feedback on this topic.</A> / Built on Thursday, January 16, 2003 </DIV>
</BODY>
</HTML>
